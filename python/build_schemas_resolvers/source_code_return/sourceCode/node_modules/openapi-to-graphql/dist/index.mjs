import { GraphQLError, GraphQLScalarType, GraphQLID, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLString, GraphQLObjectType, GraphQLInputObjectType, GraphQLUnionType, GraphQLList, GraphQLEnumType, GraphQLNonNull, GraphQLSchema } from 'graphql';
import GraphQLUpload from 'graphql-upload/GraphQLUpload.js';
import { GraphQLJSON, GraphQLBigInt } from 'graphql-scalars';
import { convertObj } from 'swagger2openapi';
import { validate } from 'oas-validator';
import debug, { debug as debug$1 } from 'debug';
import { JsonPointer } from 'json-ptr';
import { singular } from 'pluralize';
import stream from 'stream';
import { JSONPath } from 'jsonpath-plus';
import { get } from 'jsonpointer';
import formurlencoded from 'form-urlencoded';
import { PubSub } from 'graphql-subscriptions';
import urljoin from 'url-join';
import FormData from 'form-data';
import deepEqual from 'deep-equal';
import crossFetch from 'cross-fetch';

// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: openapi-to-graphql
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var GraphQLOperationType;
(function (GraphQLOperationType) {
    GraphQLOperationType[GraphQLOperationType["Query"] = 0] = "Query";
    GraphQLOperationType[GraphQLOperationType["Mutation"] = 1] = "Mutation";
    GraphQLOperationType[GraphQLOperationType["Subscription"] = 2] = "Subscription";
})(GraphQLOperationType || (GraphQLOperationType = {}));

// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: openapi-to-graphql
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var TargetGraphQLType;
(function (TargetGraphQLType) {
    // scalars
    TargetGraphQLType["string"] = "string";
    TargetGraphQLType["integer"] = "integer";
    TargetGraphQLType["float"] = "float";
    TargetGraphQLType["boolean"] = "boolean";
    TargetGraphQLType["id"] = "id";
    TargetGraphQLType["bigint"] = "bigint";
    TargetGraphQLType["upload"] = "upload";
    // JSON
    TargetGraphQLType["json"] = "json";
    // non-scalars
    TargetGraphQLType["object"] = "object";
    TargetGraphQLType["list"] = "list";
    TargetGraphQLType["enum"] = "enum";
    TargetGraphQLType["anyOfObject"] = "anyOfObject";
    TargetGraphQLType["oneOfUnion"] = "oneOfUnion";
})(TargetGraphQLType || (TargetGraphQLType = {}));

// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: openapi-to-graphql
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var MitigationTypes;
(function (MitigationTypes) {
    /**
     * Problems with the OAS
     *
     * Should be caught by the module oas-validator
     */
    MitigationTypes["INVALID_OAS"] = "INVALID_OAS";
    MitigationTypes["UNNAMED_PARAMETER"] = "UNNAMED_PARAMETER";
    // General problems
    MitigationTypes["AMBIGUOUS_UNION_MEMBERS"] = "AMBIGUOUS_UNION_MEMBERS";
    MitigationTypes["CANNOT_GET_FIELD_TYPE"] = "CANNOT_GET_FIELD_TYPE";
    MitigationTypes["COMBINE_SCHEMAS"] = "COMBINE_SCHEMAS";
    MitigationTypes["DUPLICATE_FIELD_NAME"] = "DUPLICATE_FIELD_NAME";
    MitigationTypes["DUPLICATE_LINK_KEY"] = "DUPLICATE_LINK_KEY";
    MitigationTypes["INVALID_HTTP_METHOD"] = "INVALID_HTTP_METHOD";
    MitigationTypes["INPUT_UNION"] = "INPUT_UNION";
    MitigationTypes["MISSING_RESPONSE_SCHEMA"] = "MISSING_RESPONSE_SCHEMA";
    MitigationTypes["MISSING_SCHEMA"] = "MISSING_SCHEMA";
    MitigationTypes["MULTIPLE_RESPONSES"] = "MULTIPLE_RESPONSES";
    MitigationTypes["NON_APPLICATION_JSON_SCHEMA"] = "NON_APPLICATION_JSON_SCHEMA";
    MitigationTypes["OBJECT_MISSING_PROPERTIES"] = "OBJECT_MISSING_PROPERTIES";
    MitigationTypes["UNKNOWN_TARGET_TYPE"] = "UNKNOWN_TARGET_TYPE";
    MitigationTypes["UNRESOLVABLE_SCHEMA"] = "UNRESOLVABLE_SCHEMA";
    MitigationTypes["UNSUPPORTED_HTTP_SECURITY_SCHEME"] = "UNSUPPORTED_HTTP_SECURITY_SCHEME";
    MitigationTypes["UNSUPPORTED_JSON_SCHEMA_KEYWORD"] = "UNSUPPORTED_JSON_SCHEMA_KEYWORD";
    MitigationTypes["CALLBACKS_MULTIPLE_OPERATION_OBJECTS"] = "CALLBACKS_MULTIPLE_OPERATION_OBJECTS";
    // Links
    MitigationTypes["AMBIGUOUS_LINK"] = "AMBIGUOUS_LINK";
    MitigationTypes["LINK_NAME_COLLISION"] = "LINK_NAME_COLLISION";
    MitigationTypes["UNRESOLVABLE_LINK"] = "UNRESOLVABLE_LINK";
    // Multiple OAS
    MitigationTypes["DUPLICATE_OPERATIONID"] = "DUPLICATE_OPERATIONID";
    MitigationTypes["DUPLICATE_SECURITY_SCHEME"] = "DUPLICATE_SECURITY_SCHEME";
    MitigationTypes["MULTIPLE_OAS_SAME_TITLE"] = "MULTIPLE_OAS_SAME_TITLE";
    // Options
    MitigationTypes["CUSTOM_RESOLVER_UNKNOWN_OAS"] = "CUSTOM_RESOLVER_UNKNOWN_OAS";
    MitigationTypes["CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD"] = "CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD";
    MitigationTypes["LIMIT_ARGUMENT_NAME_COLLISION"] = "LIMIT_ARGUMENT_NAME_COLLISION";
    // Miscellaneous
    MitigationTypes["OAUTH_SECURITY_SCHEME"] = "OAUTH_SECURITY_SCHEME";
})(MitigationTypes || (MitigationTypes = {}));
const mitigations = {
    /**
     * Problems with the OAS
     *
     * Should be caught by the module oas-validator
     */
    INVALID_OAS: 'Ignore issue and continue.',
    UNNAMED_PARAMETER: 'Ignore parameter.',
    // General problems
    AMBIGUOUS_UNION_MEMBERS: 'Ignore issue and continue.',
    CANNOT_GET_FIELD_TYPE: 'Ignore field and continue.',
    COMBINE_SCHEMAS: 'Ignore combine schema keyword and continue.',
    DUPLICATE_FIELD_NAME: 'Ignore field and maintain preexisting field.',
    DUPLICATE_LINK_KEY: 'Ignore link and maintain preexisting link.',
    INPUT_UNION: 'The data will be stored in an arbitrary JSON type.',
    INVALID_HTTP_METHOD: 'Ignore operation and continue.',
    MISSING_RESPONSE_SCHEMA: 'Ignore operation.',
    MISSING_SCHEMA: 'Use arbitrary JSON type.',
    MULTIPLE_RESPONSES: 'Select first response object with successful status code (200-299).',
    NON_APPLICATION_JSON_SCHEMA: 'Ignore schema',
    OBJECT_MISSING_PROPERTIES: 'The (sub-)object will be stored in an arbitrary JSON type.',
    UNKNOWN_TARGET_TYPE: 'The data will be stored in an arbitrary JSON type.',
    UNRESOLVABLE_SCHEMA: 'Ignore and continue. May lead to unexpected behavior.',
    UNSUPPORTED_HTTP_SECURITY_SCHEME: 'Ignore security scheme.',
    UNSUPPORTED_JSON_SCHEMA_KEYWORD: 'Ignore keyword and continue.',
    CALLBACKS_MULTIPLE_OPERATION_OBJECTS: 'Select arbitrary operation object',
    // Links
    AMBIGUOUS_LINK: `Use first occurance of '#/'.`,
    LINK_NAME_COLLISION: 'Ignore link and maintain preexisting field.',
    UNRESOLVABLE_LINK: 'Ignore link.',
    // Multiple OAS
    DUPLICATE_OPERATIONID: 'Ignore operation and maintain preexisting operation.',
    DUPLICATE_SECURITY_SCHEME: 'Ignore security scheme and maintain preexisting scheme.',
    MULTIPLE_OAS_SAME_TITLE: 'Ignore issue and continue.',
    // Options
    CUSTOM_RESOLVER_UNKNOWN_OAS: 'Ignore this set of custom resolvers.',
    CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD: 'Ignore this set of custom resolvers.',
    LIMIT_ARGUMENT_NAME_COLLISION: `Do not override existing 'limit' argument.`,
    // Miscellaneous
    OAUTH_SECURITY_SCHEME: `Do not create OAuth viewer. OAuth support is provided using the 'tokenJSONpath' option.`
};
/**
 * Utilities that are specific to OpenAPI-to-GraphQL
 */
function handleWarning({ mitigationType, message, mitigationAddendum, path, data, log }) {
    const mitigation = mitigations[mitigationType];
    const warning = {
        type: mitigationType,
        message,
        mitigation: mitigationAddendum
            ? `${mitigation} ${mitigationAddendum}`
            : mitigation
    };
    if (path) {
        warning['path'] = path;
    }
    if (data.options.strict) {
        throw new Error(`${warning.type} - ${warning.message}`);
    }
    else {
        const output = `Warning: ${warning.message} - ${warning.mitigation}`;
        if (typeof log === 'function') {
            log(output);
        }
        else {
            console.log(output);
        }
        data.options.report.warnings.push(warning);
    }
}
// Code provided by codename- from StackOverflow
// Link: https://stackoverflow.com/a/29622653
function sortObject(o) {
    return Object.keys(o)
        .sort()
        .reduce((r, k) => ((r[k] = o[k]), r), {});
}
/**
 * Finds the common property names between two objects
 */
function getCommonPropertyNames(object1, object2) {
    return Object.keys(object1).filter((propertyName) => {
        return propertyName in object2;
    });
}

// Copyright IBM Corp. 2018. All Rights Reserved.
const httpLog = debug('http');
const preprocessingLog = debug('preprocessing');
const translationLog = debug('translation');
// OAS constants
var HTTP_METHODS;
(function (HTTP_METHODS) {
    HTTP_METHODS["get"] = "get";
    HTTP_METHODS["put"] = "put";
    HTTP_METHODS["post"] = "post";
    HTTP_METHODS["patch"] = "patch";
    HTTP_METHODS["delete"] = "delete";
    HTTP_METHODS["options"] = "options";
    HTTP_METHODS["head"] = "head";
})(HTTP_METHODS || (HTTP_METHODS = {}));
const SUCCESS_STATUS_RX = /2[0-9]{2}|2XX/;
var OAS_GRAPHQL_EXTENSIONS;
(function (OAS_GRAPHQL_EXTENSIONS) {
    OAS_GRAPHQL_EXTENSIONS["TypeName"] = "x-graphql-type-name";
    OAS_GRAPHQL_EXTENSIONS["FieldName"] = "x-graphql-field-name";
    OAS_GRAPHQL_EXTENSIONS["EnumMapping"] = "x-graphql-enum-mapping";
})(OAS_GRAPHQL_EXTENSIONS || (OAS_GRAPHQL_EXTENSIONS = {}));
/**
 * Given an HTTP method, convert it to the HTTP_METHODS enum
 */
function methodToHttpMethod(method) {
    switch (method.toLowerCase()) {
        case 'get':
            return HTTP_METHODS.get;
        case 'put':
            return HTTP_METHODS.put;
        case 'post':
            return HTTP_METHODS.post;
        case 'patch':
            return HTTP_METHODS.patch;
        case 'delete':
            return HTTP_METHODS.delete;
        case 'options':
            return HTTP_METHODS.options;
        case 'head':
            return HTTP_METHODS.head;
        default:
            throw new Error(`Invalid HTTP method '${method}'`);
    }
}
function isOas2(spec) {
    return typeof spec.swagger === 'string' && /^2/.test(spec.swagger);
}
function isOas3(spec) {
    return typeof spec.openapi === 'string' && /^3/.test(spec.openapi);
}
/**
 * Resolves on a validated OAS 3 for the given spec (OAS 2 or OAS 3), or rejects
 * if errors occur.
 */
async function getValidOAS3(spec, oasValidatorOptions, swagger2OpenAPIOptions) {
    // CASE: translate
    if (isOas2(spec)) {
        preprocessingLog(`Received Swagger - going to translate to OpenAPI Specification...`);
        try {
            const { openapi } = await convertObj(spec, swagger2OpenAPIOptions);
            return openapi;
        }
        catch (error) {
            throw new Error(`Could not convert Swagger '${spec.info.title}' to OpenAPI Specification. ${error.message}`);
        }
        // CASE: validate
    }
    else if (isOas3(spec)) {
        preprocessingLog(`Received OpenAPI Specification - going to validate...`);
        await validate(spec, oasValidatorOptions);
    }
    else {
        throw new Error(`Invalid specification provided`);
    }
    return spec;
}
/**
 * Counts the number of operations in an OAS.
 */
function countOperations(oas) {
    let numOps = 0;
    for (let path in oas.paths) {
        for (let method in oas.paths[path]) {
            if (isHttpMethod(method)) {
                numOps++;
                if (oas.paths[path][method].callbacks) {
                    for (let cbName in oas.paths[path][method].callbacks) {
                        for (let cbPath in oas.paths[path][method].callbacks[cbName]) {
                            numOps++;
                        }
                    }
                }
            }
        }
    }
    return numOps;
}
/**
 * Counts the number of operations that translate to queries in an OAS.
 */
function countOperationsQuery(oas) {
    let numOps = 0;
    for (let path in oas.paths) {
        for (let method in oas.paths[path]) {
            if (isHttpMethod(method) && method.toLowerCase() === HTTP_METHODS.get) {
                numOps++;
            }
        }
    }
    return numOps;
}
/**
 * Counts the number of operations that translate to mutations in an OAS.
 */
function countOperationsMutation(oas) {
    let numOps = 0;
    for (let path in oas.paths) {
        for (let method in oas.paths[path]) {
            if (isHttpMethod(method) && method.toLowerCase() !== HTTP_METHODS.get) {
                numOps++;
            }
        }
    }
    return numOps;
}
/**
 * Counts the number of operations that translate to subscriptions in an OAS.
 */
function countOperationsSubscription(oas) {
    let numOps = 0;
    for (let path in oas.paths) {
        for (let method in oas.paths[path]) {
            if (isHttpMethod(method) &&
                method.toLowerCase() !== HTTP_METHODS.get &&
                oas.paths[path][method].callbacks) {
                for (let cbName in oas.paths[path][method].callbacks) {
                    for (let cbPath in oas.paths[path][method].callbacks[cbName]) {
                        numOps++;
                    }
                }
            }
        }
    }
    return numOps;
}
/**
 * Resolves the given reference in the given object.
 */
function resolveRef(ref, oas) {
    return JsonPointer.get(oas, ref);
}
/**
 * Recursively traverse a schema and resolve allOf by appending the data to the
 * parent schema
 */
function resolveAllOf(schema, references, data, oas) {
    // Dereference schema
    if ('$ref' in schema && typeof schema.$ref === 'string') {
        if (schema.$ref in references) {
            return references[schema.$ref];
        }
        const reference = schema.$ref;
        schema = resolveRef(schema.$ref, oas);
        references[reference] = schema;
    }
    /**
     * TODO: Is there a better method to copy the schema?
     *
     * Copy the schema
     */
    const collapsedSchema = JSON.parse(JSON.stringify(schema));
    // Resolve allOf
    if (Array.isArray(collapsedSchema.allOf)) {
        collapsedSchema.allOf.forEach((memberSchema) => {
            const collapsedMemberSchema = resolveAllOf(memberSchema, references, data, oas);
            // Collapse type if applicable
            if (collapsedMemberSchema.type) {
                if (!collapsedSchema.type) {
                    collapsedSchema.type = collapsedMemberSchema.type;
                    // Check for incompatible schema type
                }
                else if (collapsedSchema.type !== collapsedMemberSchema.type) {
                    handleWarning({
                        mitigationType: MitigationTypes.UNRESOLVABLE_SCHEMA,
                        message: `Resolving 'allOf' field in schema '${JSON.stringify(collapsedSchema)}' ` + `results in incompatible schema type.`,
                        data,
                        log: preprocessingLog
                    });
                }
            }
            // Collapse properties if applicable
            if ('properties' in collapsedMemberSchema) {
                if (!('properties' in collapsedSchema)) {
                    collapsedSchema.properties = {};
                }
                Object.entries(collapsedMemberSchema.properties).forEach(([propertyName, property]) => {
                    if (!(propertyName in collapsedSchema.properties)) {
                        collapsedSchema.properties[propertyName] = property;
                        // Conflicting property
                    }
                    else {
                        handleWarning({
                            mitigationType: MitigationTypes.UNRESOLVABLE_SCHEMA,
                            message: `Resolving 'allOf' field in schema '${JSON.stringify(collapsedSchema)}' ` +
                                `results in incompatible property field '${propertyName}'.`,
                            data,
                            log: preprocessingLog
                        });
                    }
                });
            }
            // Collapse oneOf if applicable
            if ('oneOf' in collapsedMemberSchema) {
                if (!('oneOf' in collapsedSchema)) {
                    collapsedSchema.oneOf = [];
                }
                collapsedMemberSchema.oneOf.forEach((oneOfProperty) => {
                    collapsedSchema.oneOf.push(oneOfProperty);
                });
            }
            // Collapse anyOf if applicable
            if ('anyOf' in collapsedMemberSchema) {
                if (!('anyOf' in collapsedSchema)) {
                    collapsedSchema.anyOf = [];
                }
                collapsedMemberSchema.anyOf.forEach((anyOfProperty) => {
                    collapsedSchema.anyOf.push(anyOfProperty);
                });
            }
            // Collapse required if applicable
            if ('required' in collapsedMemberSchema) {
                if (!('required' in collapsedSchema)) {
                    collapsedSchema.required = [];
                }
                collapsedMemberSchema.required.forEach((requiredProperty) => {
                    if (!collapsedSchema.required.includes(requiredProperty)) {
                        collapsedSchema.required.push(requiredProperty);
                    }
                });
            }
        });
    }
    return collapsedSchema;
}
/**
 * Returns the base URL to use for the given operation.
 */
function getBaseUrl(operation) {
    // Check for servers:
    if (!Array.isArray(operation.servers) || operation.servers.length === 0) {
        throw new Error(`No servers defined for operation '${operation.operationString}'`);
    }
    // Check for local servers
    if (Array.isArray(operation.servers) && operation.servers.length > 0) {
        const url = buildUrl(operation.servers[0]);
        if (Array.isArray(operation.servers) && operation.servers.length > 1) {
            httpLog(`Warning: Randomly selected first server '${url}'`);
        }
        return url.replace(/\/$/, '');
    }
    const oas = operation.oas;
    if (Array.isArray(oas.servers) && oas.servers.length > 0) {
        const url = buildUrl(oas.servers[0]);
        if (Array.isArray(oas.servers) && oas.servers.length > 1) {
            httpLog(`Warning: Randomly selected first server '${url}'`);
        }
        return url.replace(/\/$/, '');
    }
    throw new Error('Cannot find a server to call');
}
/**
 * Returns the default URL for a given OAS server object.
 */
function buildUrl(server) {
    let url = server.url;
    // Replace with variable defaults, if applicable
    if (typeof server.variables === 'object' &&
        Object.keys(server.variables).length > 0) {
        for (let variableKey in server.variables) {
            // TODO: check for default? Would be invalid OAS
            url = url.replace(`{${variableKey}}`, server.variables[variableKey].default.toString());
        }
    }
    return url;
}
/**
 * Returns object/array/scalar where all object keys (if applicable) are
 * sanitized.
 */
function sanitizeObjectKeys(obj, // obj does not necessarily need to be an object
caseStyle = CaseStyle.camelCase) {
    const cleanKeys = (obj) => {
        // Case: no (response) data
        if (obj === null || typeof obj === 'undefined') {
            return null;
            // Case: array
        }
        else if (Array.isArray(obj)) {
            return obj.map(cleanKeys);
            // Case: object
        }
        else if (typeof obj === 'object') {
            const res = {};
            for (const key in obj) {
                const saneKey = sanitize(key, caseStyle);
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[saneKey] = cleanKeys(obj[key]);
                }
            }
            return res;
            // Case: scalar
        }
        else {
            return obj;
        }
    };
    return cleanKeys(obj);
}
/**
 * Desanitizes keys in given object by replacing them with the keys stored in
 * the given mapping.
 */
function desanitizeObjectKeys(obj, mapping = {}) {
    const replaceKeys = (obj) => {
        if (obj === null) {
            return null;
        }
        else if (Array.isArray(obj)) {
            return obj.map(replaceKeys);
        }
        else if (typeof obj === 'object') {
            const res = {};
            for (let key in obj) {
                if (key in mapping) {
                    const rawKey = mapping[key];
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        res[rawKey] = replaceKeys(obj[key]);
                    }
                }
                else {
                    res[key] = replaceKeys(obj[key]);
                }
            }
            return res;
        }
        else {
            return obj;
        }
    };
    return replaceKeys(obj);
}
/**
 * Returns the GraphQL type that the provided schema should be made into
 */
function getSchemaTargetGraphQLType(schemaOrRef, data, oas) {
    let schema;
    if ('$ref' in schemaOrRef && typeof schemaOrRef.$ref === 'string') {
        schema = resolveRef(schemaOrRef.$ref, oas);
    }
    else {
        schema = schemaOrRef;
    }
    // TODO: Need to resolve allOf here as well.
    // CASE: Check for nested or concurrent anyOf and oneOf
    if (
    // TODO: Should also consider if the member schema contains type data
    (Array.isArray(schema.anyOf) && Array.isArray(schema.oneOf)) || // anyOf and oneOf used concurrently
        hasNestedAnyOfUsage(schema, oas) ||
        hasNestedOneOfUsage(schema, oas)) {
        handleWarning({
            mitigationType: MitigationTypes.COMBINE_SCHEMAS,
            message: `Schema '${JSON.stringify(schema)}' contains either both ` +
                `'anyOf' and 'oneOf' or nested 'anyOf' and 'oneOf' which ` +
                `is currently not supported.`,
            mitigationAddendum: `Use arbitrary JSON type instead.`,
            data,
            log: preprocessingLog
        });
        return TargetGraphQLType.json;
    }
    if (Array.isArray(schema.anyOf)) {
        return GetAnyOfTargetGraphQLType(schema, data, oas);
    }
    if (Array.isArray(schema.oneOf)) {
        return GetOneOfTargetGraphQLType(schema, data, oas);
    }
    // CASE: enum
    if (Array.isArray(schema.enum)) {
        return TargetGraphQLType.enum;
    }
    // CASE: object
    if (schema.type === 'object' || typeof schema.properties === 'object') {
        // TODO: additionalProperties is more like a flag than a type itself
        // CASE: arbitrary JSON
        if (typeof schema.additionalProperties === 'object') {
            return TargetGraphQLType.json;
        }
        else {
            return TargetGraphQLType.object;
        }
    }
    // CASE: array
    if (schema.type === 'array' || 'items' in schema) {
        return TargetGraphQLType.list;
    }
    // Special edge cases involving the schema format
    if (typeof schema.format === 'string') {
        if (schema.type === 'integer' && schema.format === 'int64') {
            return TargetGraphQLType.bigint;
            // CASE: file upload
        }
        else if (schema.type === 'string' && schema.format === 'binary') {
            return TargetGraphQLType.upload;
            // CASE: id
        }
        else if (schema.type === 'string' &&
            (schema.format === 'uuid' ||
                // Custom ID format
                (Array.isArray(data.options.idFormats) &&
                    data.options.idFormats.includes(schema.format)))) {
            return TargetGraphQLType.id;
        }
    }
    switch (schema.type) {
        case 'string':
            return TargetGraphQLType.string;
        case 'number':
            return TargetGraphQLType.float;
        case 'integer':
            return TargetGraphQLType.integer;
        case 'boolean':
            return TargetGraphQLType.boolean;
        // Error: unsupported schema type
    }
    return null;
}
/**
 * Check to see if there are cases of nested oneOf fields in the member schemas
 *
 * We currently cannot handle complex cases of oneOf and anyOf
 */
function hasNestedOneOfUsage(schema, oas) {
    // TODO: Should also consider if the member schema contains type data
    return (Array.isArray(schema.oneOf) &&
        schema.oneOf.some((memberSchemaOrRef) => {
            let memberSchema;
            if ('$ref' in memberSchemaOrRef &&
                typeof memberSchemaOrRef.$ref === 'string') {
                memberSchema = resolveRef(memberSchemaOrRef.$ref, oas);
            }
            else {
                memberSchema = memberSchemaOrRef;
            }
            return (
            /**
             * anyOf and oneOf are nested
             *
             * Nested oneOf would result in nested unions which are not allowed by
             * GraphQL
             */
            Array.isArray(memberSchema.anyOf) || Array.isArray(memberSchema.oneOf));
        }));
}
/**
 * Check to see if there are cases of nested anyOf fields in the member schemas
 *
 * We currently cannot handle complex cases of oneOf and anyOf
 */
function hasNestedAnyOfUsage(schema, oas) {
    // TODO: Should also consider if the member schema contains type data
    return (Array.isArray(schema.anyOf) &&
        schema.anyOf.some((memberSchemaOrRef) => {
            let memberSchema;
            if ('$ref' in memberSchemaOrRef &&
                typeof memberSchemaOrRef.$ref === 'string') {
                memberSchema = resolveRef(memberSchemaOrRef.$ref, oas);
            }
            else {
                memberSchema = memberSchemaOrRef;
            }
            return (
            // anyOf and oneOf are nested
            Array.isArray(memberSchema.anyOf) || Array.isArray(memberSchema.oneOf));
        }));
}
function GetAnyOfTargetGraphQLType(schema, data, oas) {
    // Identify the type of the base schema, meaning ignoring the anyOf
    const schemaWithNoAnyOf = { ...schema };
    delete schemaWithNoAnyOf.anyOf;
    const baseTargetType = getSchemaTargetGraphQLType(schemaWithNoAnyOf, data, oas);
    // Target GraphQL types of all the member schemas
    const memberTargetTypes = [];
    schema.anyOf.forEach((memberSchema) => {
        const memberTargetType = getSchemaTargetGraphQLType(memberSchema, data, oas);
        if (memberTargetType !== null) {
            memberTargetTypes.push(memberTargetType);
        }
    });
    if (memberTargetTypes.length > 0) {
        const firstMemberTargetType = memberTargetTypes[0];
        const consistentMemberTargetTypes = memberTargetTypes.every((targetType) => {
            return targetType === firstMemberTargetType;
        });
        if (consistentMemberTargetTypes) {
            if (baseTargetType !== null) {
                if (baseTargetType === firstMemberTargetType) {
                    if (baseTargetType === 'object') {
                        // Base schema and member schema types are object types
                        return TargetGraphQLType.anyOfObject;
                    }
                    else {
                        // Base schema and member schema types but no object types
                        return baseTargetType;
                    }
                }
                else {
                    // Base schema and member schema types are not consistent
                    return TargetGraphQLType.json;
                }
            }
            else {
                if (firstMemberTargetType === TargetGraphQLType.object) {
                    return TargetGraphQLType.anyOfObject;
                }
                else {
                    return firstMemberTargetType;
                }
            }
        }
        else {
            // Member schema types are not consistent
            return TargetGraphQLType.json;
        }
    }
    else {
        // No member schema types, therefore use the base schema type
        return baseTargetType;
    }
}
function GetOneOfTargetGraphQLType(schema, data, oas) {
    // Identify the type of the base schema, meaning ignoring the oneOf
    const schemaWithNoOneOf = { ...schema };
    delete schemaWithNoOneOf.oneOf;
    const baseTargetType = getSchemaTargetGraphQLType(schemaWithNoOneOf, data, oas);
    // Target GraphQL types of all the member schemas
    const memberTargetTypes = [];
    schema.oneOf.forEach((memberSchema) => {
        const collapsedMemberSchema = resolveAllOf(memberSchema, {}, data, oas);
        const memberTargetType = getSchemaTargetGraphQLType(collapsedMemberSchema, data, oas);
        if (memberTargetType !== null) {
            memberTargetTypes.push(memberTargetType);
        }
    });
    if (memberTargetTypes.length > 0) {
        const firstMemberTargetType = memberTargetTypes[0];
        const consistentMemberTargetTypes = memberTargetTypes.every((targetType) => {
            return targetType === firstMemberTargetType;
        });
        if (consistentMemberTargetTypes) {
            if (baseTargetType !== null) {
                if (baseTargetType === firstMemberTargetType) {
                    if (baseTargetType === 'object') {
                        // Base schema and member schema types are object types
                        return TargetGraphQLType.oneOfUnion;
                    }
                    else {
                        // Base schema and member schema types but no object types
                        return baseTargetType;
                    }
                }
                else {
                    // Base schema and member schema types are not consistent
                    return TargetGraphQLType.json;
                }
            }
            else {
                if (firstMemberTargetType === TargetGraphQLType.object) {
                    return TargetGraphQLType.oneOfUnion;
                }
                else {
                    return firstMemberTargetType;
                }
            }
        }
        else {
            // Member schema types are not consistent
            return TargetGraphQLType.json;
        }
    }
    else {
        // No member schema types, therefore use the base schema type
        return baseTargetType;
    }
}
function isIdParam(part) {
    return /^{.*(id|name|key).*}$/gi.test(part);
}
function isSingularParam(part, nextPart) {
    return `\{${singular(part)}\}` === nextPart;
}
/**
 * Infers a resource name from the given URL path.
 *
 * For example, turns "/users/{userId}/car" into "userCar".
 */
function inferResourceNameFromPath(path) {
    const parts = path.split('/');
    let pathNoPathParams = parts.reduce((path, part, i) => {
        if (!/{/g.test(part)) {
            if (parts[i + 1] &&
                (isIdParam(parts[i + 1]) || isSingularParam(part, parts[i + 1]))) {
                return path + capitalize(singular(part));
            }
            else {
                return path + capitalize(part);
            }
        }
        else {
            return path;
        }
    }, '');
    return pathNoPathParams;
}
/**
 * Returns the request schema (if any) for the given operation,
 * a dictionary of names from different sources (if available), and whether the
 * request schema is required for the operation.
 */
function getRequestSchemaAndNames(path, method, operation, oas) {
    var _a;
    let payloadContentType; // randomly selected content-type, prioritizing application/json
    let requestBodyObject; // request object
    let payloadSchema; // request schema with given content-type
    let payloadSchemaNames; // dictionary of names
    let payloadRequired = false;
    // Get request body
    const requestBodyObjectOrRef = operation === null || operation === void 0 ? void 0 : operation.requestBody;
    if (typeof requestBodyObjectOrRef === 'object' &&
        requestBodyObjectOrRef !== null) {
        // Resolve reference if applicable. Make sure we have a RequestBodyObject:
        if ('$ref' in requestBodyObjectOrRef &&
            typeof requestBodyObjectOrRef.$ref === 'string') {
            requestBodyObject = resolveRef(requestBodyObjectOrRef.$ref, oas);
        }
        else {
            requestBodyObject = requestBodyObjectOrRef;
        }
        if (typeof requestBodyObject === 'object' && requestBodyObject !== null) {
            // Determine if request body is required:
            payloadRequired =
                typeof (requestBodyObject === null || requestBodyObject === void 0 ? void 0 : requestBodyObject.required) === 'boolean'
                    ? requestBodyObject === null || requestBodyObject === void 0 ? void 0 : requestBodyObject.required
                    : false;
            // Determine content-type
            const content = requestBodyObject === null || requestBodyObject === void 0 ? void 0 : requestBodyObject.content;
            if (typeof content === 'object' &&
                content !== null &&
                Object.keys(content).length > 0) {
                // Prioritize content-type JSON
                if ('application/json' in content) {
                    payloadContentType = 'application/json';
                }
                else if ('application/x-www-form-urlencoded' in content) {
                    payloadContentType = 'application/x-www-form-urlencoded';
                }
                else {
                    // Pick first (random) content type
                    const randomContentType = Object.keys(content)[0];
                    payloadContentType = randomContentType;
                }
                if (payloadContentType === 'application/json' ||
                    payloadContentType === '*/*' ||
                    payloadContentType === 'application/x-www-form-urlencoded' ||
                    payloadContentType === 'multipart/form-data') {
                    // Name extracted from a reference, if applicable
                    let fromRef;
                    // Determine payload schema
                    const payloadSchemaOrRef = (_a = content === null || content === void 0 ? void 0 : content[payloadContentType]) === null || _a === void 0 ? void 0 : _a.schema;
                    if (typeof payloadSchemaOrRef === 'object' &&
                        payloadSchemaOrRef !== null) {
                        // Resolve payload schema reference if applicable
                        if ('$ref' in payloadSchemaOrRef &&
                            typeof payloadSchemaOrRef.$ref === 'string') {
                            fromRef = payloadSchemaOrRef.$ref.split('/').pop();
                            payloadSchema = resolveRef(payloadSchemaOrRef.$ref, oas);
                        }
                        else {
                            payloadSchema = payloadSchemaOrRef;
                        }
                    }
                    // Determine possible schema names
                    payloadSchemaNames = {
                        fromExtension: payloadSchema[OAS_GRAPHQL_EXTENSIONS.TypeName],
                        fromRef,
                        fromSchema: payloadSchema === null || payloadSchema === void 0 ? void 0 : payloadSchema.title,
                        fromPath: inferResourceNameFromPath(path)
                    };
                    /**
                     * Edge case: if request body content-type is not application/json or
                     * application/x-www-form-urlencoded, do not parse it.
                     *
                     * Instead, treat the request body as a black box and send it as a string
                     * with the proper content-type header
                     */
                }
                else {
                    const saneContentTypeName = uncapitalize(payloadContentType.split('/').reduce((name, term) => {
                        return name + capitalize(term);
                    }));
                    let description = `String represents payload of content type '${payloadContentType}'`;
                    if (typeof (payloadSchema === null || payloadSchema === void 0 ? void 0 : payloadSchema.description) === 'string') {
                        description += `\n\nOriginal top level description: '${payloadSchema.description}'`;
                    }
                    // Replacement schema to avoid parsing
                    payloadSchema = {
                        description,
                        type: 'string'
                    };
                    // Determine possible schema names
                    payloadSchemaNames = {
                        fromPath: saneContentTypeName
                    };
                }
            }
        }
    }
    return {
        payloadContentType,
        payloadSchema,
        payloadSchemaNames,
        payloadRequired
    };
}
/**
 * Returns the response schema for the given operation,
 * a successful status code, and a dictionary of names from different sources
 * (if available).
 */
function getResponseSchemaAndNames(path, method, operation, oas, data, options) {
    var _a, _b, _c;
    let responseContentType; // randomly selected content-type, prioritizing application/json
    let responseObject; // response object
    let responseSchema; // response schema with given content-type
    let responseSchemaNames; // dictionary of names
    const statusCode = getResponseStatusCode(path, method, operation, oas, data);
    // Get response object
    const responseObjectOrRef = (_a = operation === null || operation === void 0 ? void 0 : operation.responses) === null || _a === void 0 ? void 0 : _a[statusCode];
    if (typeof responseObjectOrRef === 'object' && responseObjectOrRef !== null) {
        if ('$ref' in responseObjectOrRef &&
            typeof responseObjectOrRef.$ref === 'string') {
            responseObject = resolveRef(responseObjectOrRef.$ref, oas);
        }
        else {
            responseObject = responseObjectOrRef;
        }
        // Determine content-type
        if (typeof responseObject === 'object' && responseObject !== null) {
            const content = responseObject === null || responseObject === void 0 ? void 0 : responseObject.content;
            if (typeof content === 'object' &&
                content !== null &&
                Object.keys(content).length > 0) {
                // Prioritize content-type JSON
                if ('application/json' in content) {
                    responseContentType = 'application/json';
                }
                else {
                    // Pick first (random) content type
                    const randomContentType = Object.keys(content)[0];
                    responseContentType = randomContentType;
                }
                if (responseContentType === 'application/json' ||
                    responseContentType === '*/*') {
                    // Name from reference, if applicable
                    let fromRef;
                    // Determine response schema
                    const responseSchemaOrRef = (_c = (_b = responseObject === null || responseObject === void 0 ? void 0 : responseObject.content) === null || _b === void 0 ? void 0 : _b[responseContentType]) === null || _c === void 0 ? void 0 : _c.schema;
                    // Resolve response schema reference if applicable
                    if ('$ref' in responseSchemaOrRef &&
                        typeof responseSchemaOrRef.$ref === 'string') {
                        fromRef = responseSchemaOrRef.$ref.split('/').pop();
                        responseSchema = resolveRef(responseSchemaOrRef.$ref, oas);
                    }
                    else {
                        responseSchema = responseSchemaOrRef;
                    }
                    // Determine possible schema names
                    responseSchemaNames = {
                        fromExtension: responseSchema[OAS_GRAPHQL_EXTENSIONS.TypeName],
                        fromRef,
                        fromSchema: responseSchema === null || responseSchema === void 0 ? void 0 : responseSchema.title,
                        fromPath: inferResourceNameFromPath(path)
                    };
                    /**
                     * Edge case: if response body content-type is not application/json,
                     * do not parse.
                     */
                }
                else {
                    let description = 'Placeholder to access non-application/json response bodies';
                    if (typeof (responseSchema === null || responseSchema === void 0 ? void 0 : responseSchema.description) === 'string') {
                        description += `\n\nOriginal top level description: '${responseSchema.description}'`;
                    }
                    // Replacement schema to avoid parsing
                    responseSchema = {
                        description,
                        type: 'string'
                    };
                    // Determine possible schema names
                    responseSchemaNames = {
                        fromExtension: responseSchema === null || responseSchema === void 0 ? void 0 : responseSchema[OAS_GRAPHQL_EXTENSIONS.TypeName],
                        fromSchema: responseSchema === null || responseSchema === void 0 ? void 0 : responseSchema.title,
                        fromPath: inferResourceNameFromPath(path)
                    };
                }
                return {
                    responseContentType,
                    responseSchema,
                    responseSchemaNames,
                    statusCode
                };
            }
        }
    }
    // No response schema
    if (options.fillEmptyResponses) {
        return {
            responseSchemaNames: {
                fromPath: inferResourceNameFromPath(path)
            },
            responseSchema: {
                description: 'Placeholder to support operations with no response schema',
                type: 'string'
            }
        };
    }
    else {
        return {};
    }
}
/**
 * Returns a success status code for the given operation
 */
function getResponseStatusCode(path, method, operation, oas, data) {
    if (typeof operation.responses === 'object' && operation.responses !== null) {
        const codes = Object.keys(operation.responses);
        const successCodes = codes.filter((code) => {
            return SUCCESS_STATUS_RX.test(code);
        });
        if (successCodes.length === 1) {
            return successCodes[0];
        }
        else if (successCodes.length > 1) {
            // Select a random success code
            handleWarning({
                mitigationType: MitigationTypes.MULTIPLE_RESPONSES,
                message: `Operation '${formatOperationString(method, path, oas.info.title)}' ` +
                    `contains multiple possible successful response object ` +
                    `(HTTP code 200-299 or 2XX). Only one can be chosen.`,
                mitigationAddendum: `The response object with the HTTP code ` +
                    `${successCodes[0]} will be selected`,
                data,
                log: translationLog
            });
            return successCodes[0];
        }
    }
}
/**
 * Returns a hash containing the links in the given operation.
 */
function getLinks(path, method, operation, oas, data) {
    const links = {};
    const statusCode = getResponseStatusCode(path, method, operation, oas, data);
    if (!statusCode) {
        return links;
    }
    if (typeof operation.responses === 'object') {
        const responses = operation.responses;
        if (typeof responses[statusCode] === 'object') {
            const responseObjectOrRef = responses[statusCode];
            let response;
            if ('$ref' in responseObjectOrRef &&
                typeof responseObjectOrRef.$ref === 'string') {
                response = resolveRef(responseObjectOrRef.$ref, oas);
            }
            else {
                response = responseObjectOrRef;
            }
            if (typeof response.links === 'object') {
                const epLinks = response.links;
                for (let linkKey in epLinks) {
                    const linkObjectOrRef = epLinks[linkKey];
                    let link;
                    if ('$ref' in linkObjectOrRef &&
                        typeof linkObjectOrRef.$ref === 'string') {
                        link = resolveRef(linkObjectOrRef.$ref, oas);
                    }
                    else {
                        link = linkObjectOrRef;
                    }
                    links[linkKey] = link;
                }
            }
        }
    }
    return links;
}
/**
 * Returns the list of parameters in the given operation.
 */
function getParameters(path, method, operation, pathItem, oas) {
    let parameters = [];
    if (!isHttpMethod(method)) {
        translationLog(`Warning: attempted to get parameters for ${method} ${path}, ` +
            `which is not an operation.`);
        return parameters;
    }
    // First, consider parameters in Path Item Object:
    const pathParams = pathItem.parameters;
    if (Array.isArray(pathParams)) {
        const pathItemParameters = pathParams.map((p) => {
            if ('$ref' in p && typeof p.$ref === 'string') {
                // Here we know we have a parameter object:
                return resolveRef(p.$ref, oas);
            }
            else {
                // Here we know we have a parameter object:
                return p;
            }
        });
        parameters = parameters.concat(pathItemParameters);
    }
    // Second, consider parameters in Operation Object:
    const opObjectParameters = operation.parameters;
    if (Array.isArray(opObjectParameters)) {
        const operationParameters = opObjectParameters.map((p) => {
            if ('$ref' in p && typeof p.$ref === 'string') {
                // Here we know we have a parameter object:
                return resolveRef(p.$ref, oas);
            }
            else {
                // Here we know we have a parameter object:
                return p;
            }
        });
        parameters = parameters.concat(operationParameters);
    }
    return parameters;
}
/**
 * Returns an array of server objects for the operation at the given path and
 * method. Considers in the following order: global server definitions,
 * definitions at the path item, definitions at the operation, or the OAS
 * default.
 */
function getServers(operation, pathItem, oas) {
    let servers = [];
    // Global server definitions:
    if (Array.isArray(oas.servers) && oas.servers.length > 0) {
        servers = oas.servers;
    }
    // First, consider servers defined on the path
    if (Array.isArray(pathItem.servers) && pathItem.servers.length > 0) {
        servers = pathItem.servers;
    }
    // Second, consider servers defined on the operation
    if (Array.isArray(operation.servers) && operation.servers.length > 0) {
        servers = operation.servers;
    }
    // Default, in case there is no server:
    if (servers.length === 0) {
        let server = {
            url: '/' // TODO: avoid double-slashes
        };
        servers.push(server);
    }
    return servers;
}
/**
 * Returns a map of security scheme definitions, identified by keys. Resolves
 * possible references.
 */
function getSecuritySchemes(oas) {
    // Collect all security schemes:
    const securitySchemes = {};
    if (typeof oas.components === 'object' &&
        typeof oas.components.securitySchemes === 'object') {
        for (let schemeKey in oas.components.securitySchemes) {
            const securitySchemeOrRef = oas.components.securitySchemes[schemeKey];
            // Ensure we have actual SecuritySchemeObject:
            if ('$ref' in securitySchemeOrRef &&
                typeof securitySchemeOrRef.$ref === 'string') {
                // Result of resolution will be SecuritySchemeObject:
                securitySchemes[schemeKey] = resolveRef(securitySchemeOrRef.$ref, oas);
            }
            else {
                // We already have a SecuritySchemeObject:
                securitySchemes[schemeKey] = securitySchemeOrRef;
            }
        }
    }
    return securitySchemes;
}
/**
 * Returns the list of sanitized keys of non-OAuth2 security schemes
 * required by the operation at the given path and method.
 */
function getSecurityRequirements(operation, securitySchemes, oas) {
    const results = [];
    // First, consider global requirements
    const globalSecurity = oas.security;
    if (globalSecurity && typeof globalSecurity !== 'undefined') {
        for (let secReq of globalSecurity) {
            for (let schemaKey in secReq) {
                if (securitySchemes[schemaKey] &&
                    typeof securitySchemes[schemaKey] === 'object' &&
                    securitySchemes[schemaKey].def.type !== 'oauth2') {
                    results.push(schemaKey);
                }
            }
        }
    }
    // Second, consider operation requirements
    const localSecurity = operation.security;
    if (localSecurity && typeof localSecurity !== 'undefined') {
        for (let secReq of localSecurity) {
            for (let schemaKey in secReq) {
                if (securitySchemes[schemaKey] &&
                    typeof securitySchemes[schemaKey] === 'object' &&
                    securitySchemes[schemaKey].def.type !== 'oauth2') {
                    if (!results.includes(schemaKey)) {
                        results.push(schemaKey);
                    }
                }
            }
        }
    }
    return results;
}
var CaseStyle;
(function (CaseStyle) {
    CaseStyle[CaseStyle["simple"] = 0] = "simple";
    CaseStyle[CaseStyle["PascalCase"] = 1] = "PascalCase";
    CaseStyle[CaseStyle["camelCase"] = 2] = "camelCase";
    CaseStyle[CaseStyle["ALL_CAPS"] = 3] = "ALL_CAPS"; // Used for enum values
})(CaseStyle || (CaseStyle = {}));
/**
 * Checks to see if the provided string is GraphQL-safe
 */
function isSanitized(str) {
    return /[a-zA-Z0-9_]/gi.test(str);
}
/**
 * First sanitizes given string and then also camelCases it.
 */
function sanitize(str, caseStyle) {
    /**
     * Used in conjunction to simpleNames, which only removes illegal
     * characters and preserves casing
     */
    if (caseStyle === CaseStyle.simple) {
        let sanitized = str.replace(/[^a-zA-Z0-9_]/gi, '');
        // Special case: we cannot start with number, and cannot be empty:
        if (/^[0-9]/.test(sanitized) || sanitized === '') {
            sanitized = '_' + sanitized;
        }
        return sanitized;
    }
    /**
     * Remove all GraphQL unsafe characters
     */
    const regex = caseStyle === CaseStyle.ALL_CAPS
        ? /[^a-zA-Z0-9_]/g // ALL_CAPS has underscores
        : /[^a-zA-Z0-9]/g;
    let sanitized = str.split(regex).reduce((path, part) => {
        if (caseStyle === CaseStyle.ALL_CAPS) {
            return path + '_' + part;
        }
        else {
            return path + capitalize(part);
        }
    });
    switch (caseStyle) {
        case CaseStyle.PascalCase:
            // The first character in PascalCase should be uppercase
            sanitized = capitalize(sanitized);
            break;
        case CaseStyle.camelCase:
            // The first character in camelCase should be lowercase
            sanitized = uncapitalize(sanitized);
            break;
        case CaseStyle.ALL_CAPS:
            sanitized = sanitized.toUpperCase();
            break;
    }
    // Special case: we cannot start with number, and cannot be empty:
    if (/^[0-9]/.test(sanitized) || sanitized === '') {
        sanitized = '_' + sanitized;
    }
    return sanitized;
}
/**
 * Sanitizes the given string and stores the sanitized-to-original mapping in
 * the given mapping.
 */
function storeSaneName(saneStr, str, mapping) {
    if (saneStr in mapping && str !== mapping[saneStr]) {
        // TODO: Follow warning model
        translationLog(`Warning: '${str}' and '${mapping[saneStr]}' both sanitize ` +
            `to '${saneStr}' - collision possible. Desanitize to '${str}'.`);
    }
    mapping[saneStr] = str;
    return saneStr;
}
/**
 * Stringifies and possibly trims the given string to the provided length.
 */
function trim(str, length) {
    if (typeof str !== 'string') {
        str = JSON.stringify(str);
    }
    if (str && str.length > length) {
        str = `${str.substring(0, length)}...`;
    }
    return str;
}
/**
 * Determines if the given "method" is indeed an operation. Alternatively, the
 * method could point to other types of information (e.g., parameters, servers).
 */
function isHttpMethod(method) {
    return Object.keys(HTTP_METHODS).includes(method.toLowerCase());
}
/**
 * Formats a string that describes an operation in the form:
 * {name of OAS} {HTTP method in ALL_CAPS} {operation path}
 *
 * Also used in preprocessing.ts where Operation objects are being constructed
 */
function formatOperationString(method, path, title) {
    if (title) {
        return `${title} ${method.toUpperCase()} ${path}`;
    }
    else {
        return `${method.toUpperCase()} ${path}`;
    }
}
/**
 * Capitalizes a given string
 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * Uncapitalizes a given string
 */
function uncapitalize(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
/**
 * For operations that do not have an operationId, generate one
 */
function generateOperationId(method, path) {
    return sanitize(`${method} ${path}`, CaseStyle.camelCase);
}

// Copyright IBM Corp. 2018. All Rights Reserved.
const pubsub = new PubSub();
const translationLog$1 = debug$1('translation');
const httpLog$1 = debug$1('http');
const pubsubLog = debug$1('pubsub');
const uploadLog = debug$1('fileUpload');
// OAS runtime expression reference locations
const RUNTIME_REFERENCES = ['header.', 'query.', 'path.', 'body'];
const OPENAPI_TO_GRAPHQL = '_openAPIToGraphQL';
/*
 * If the operation type is Subscription, create and return a resolver object
 * that contains subscribe to perform subscription and resolve to execute
 * payload transformation
 */
function getSubscribe({ operation, payloadName, data, baseUrl, connectOptions }) {
    // Determine the appropriate URL:
    if (typeof baseUrl === 'undefined') {
        baseUrl = getBaseUrl(operation);
    }
    // Return custom resolver if it is defined
    const customResolvers = data.options.customSubscriptionResolvers;
    const title = operation.oas.info.title;
    const path = operation.path;
    const method = operation.method;
    if (typeof customResolvers === 'object' &&
        typeof customResolvers[title] === 'object' &&
        typeof customResolvers[title][path] === 'object' &&
        typeof customResolvers[title][path][method] === 'object' &&
        typeof customResolvers[title][path][method].subscribe === 'function') {
        translationLog$1(`Use custom publish resolver for ${operation.operationString}`);
        return customResolvers[title][path][method].subscribe;
    }
    return (root, args, context, info) => {
        /**
         * Determine possible topic(s) by resolving callback path
         *
         * GraphQL produces sanitized payload names, so we have to sanitize before
         * lookup here
         */
        const paramName = sanitize(payloadName, CaseStyle.camelCase);
        let resolveData = {};
        if (payloadName && typeof payloadName === 'string') {
            // The option genericPayloadArgName will change the payload name to "requestBody"
            const sanePayloadName = data.options.genericPayloadArgName
                ? 'requestBody'
                : sanitize(payloadName, CaseStyle.camelCase);
            if (sanePayloadName in args) {
                if (typeof args[sanePayloadName] === 'object') {
                    const rawPayload = desanitizeObjectKeys(args[sanePayloadName], data.saneMap);
                    resolveData.usedPayload = rawPayload;
                }
                else {
                    const rawPayload = JSON.parse(args[sanePayloadName]);
                    resolveData.usedPayload = rawPayload;
                }
            }
        }
        if (connectOptions) {
            resolveData.usedRequestOptions = connectOptions;
        }
        else {
            resolveData.usedRequestOptions = {
                method: resolveData.usedPayload.method
                    ? resolveData.usedPayload.method
                    : method.toUpperCase()
            };
        }
        pubsubLog(`Subscription schema: ${JSON.stringify(resolveData.usedPayload)}`);
        let value = path;
        let paramNameWithoutLocation = paramName;
        if (paramName.indexOf('.') !== -1) {
            paramNameWithoutLocation = paramName.split('.')[1];
        }
        // See if the callback path contains constants expression
        if (value.search(/{|}/) === -1) {
            args[paramNameWithoutLocation] = isRuntimeExpression(value)
                ? resolveRuntimeExpression(paramName, value, resolveData, root)
                : value;
        }
        else {
            // Replace callback expression with appropriate values
            const cbParams = value.match(/{([^}]*)}/g);
            pubsubLog(`Analyzing subscription path: ${cbParams.toString()}`);
            cbParams.forEach((cbParam) => {
                value = value.replace(cbParam, resolveRuntimeExpression(paramName, cbParam.substring(1, cbParam.length - 1), resolveData, root));
            });
            args[paramNameWithoutLocation] = value;
        }
        const topic = args[paramNameWithoutLocation] || 'test';
        pubsubLog(`Subscribing to: ${topic}`);
        return context.pubsub
            ? context.pubsub.asyncIterator(topic)
            : pubsub.asyncIterator(topic);
    };
}
/*
 * If the operation type is Subscription, create and return a resolver function
 * triggered after a message has been published to the corresponding subscribe
 * topic(s) to execute payload transformation
 */
function getPublishResolver({ operation, responseName, data }) {
    // Return custom resolver if it is defined
    const customResolvers = data.options.customSubscriptionResolvers;
    const title = operation.oas.info.title;
    const path = operation.path;
    const method = operation.method;
    if (typeof customResolvers === 'object' &&
        typeof customResolvers[title] === 'object' &&
        typeof customResolvers[title][path] === 'object' &&
        typeof customResolvers[title][path][method] === 'object' &&
        typeof customResolvers[title][path][method].resolve === 'function') {
        translationLog$1(`Use custom publish resolver for ${operation.operationString}`);
        return customResolvers[title][path][method].resolve;
    }
    return (payload, args, context, info) => {
        // Validate and format based on operation.responseDefinition
        const typeOfResponse = operation.responseDefinition.targetGraphQLType;
        pubsubLog(`Message received: ${responseName}, ${typeOfResponse}, ${JSON.stringify(payload)}`);
        let responseBody;
        let saneData;
        if (typeof payload === 'object') {
            if (typeOfResponse === TargetGraphQLType.object) {
                if (Buffer.isBuffer(payload)) {
                    try {
                        responseBody = JSON.parse(payload.toString());
                    }
                    catch (e) {
                        const errorString = `Cannot JSON parse payload` +
                            `operation ${operation.operationString} ` +
                            `even though it has content-type 'application/json'`;
                        pubsubLog(errorString);
                        return null;
                    }
                }
                else {
                    responseBody = payload;
                }
                saneData = sanitizeObjectKeys(payload);
            }
            else if ((Buffer.isBuffer(payload) || Array.isArray(payload)) &&
                typeOfResponse === TargetGraphQLType.string) {
                saneData = payload.toString();
            }
        }
        else if (typeof payload === 'string') {
            if (typeOfResponse === TargetGraphQLType.object) {
                try {
                    responseBody = JSON.parse(payload);
                    saneData = sanitizeObjectKeys(responseBody);
                }
                catch (e) {
                    const errorString = `Cannot JSON parse payload` +
                        `operation ${operation.operationString} ` +
                        `even though it has content-type 'application/json'`;
                    pubsubLog(errorString);
                    return null;
                }
            }
            else if (typeOfResponse === TargetGraphQLType.string) {
                saneData = payload;
            }
        }
        pubsubLog(`Message forwarded: ${JSON.stringify(saneData ? saneData : payload)}`);
        return saneData ? saneData : payload;
    };
}
/**
 * Returns values for link arguments, also covers the cases for
 * if the link parameter contains constants that are appended to the link parameter
 *
 * e.g. instead of:
 * $response.body#/employerId
 *
 * it could be:
 * abc_{$response.body#/employerId}
 */
function inferLinkArguments({ paramName, value, resolveData, source, args }) {
    if (typeof value === 'object') {
        return Object.entries(value).reduce((acc, [key, value]) => {
            acc[key] = inferLinkArguments({
                paramName,
                value,
                resolveData,
                source,
                args
            });
            return acc;
        }, {});
    }
    if (typeof value !== 'string') {
        return value;
    }
    else if (value.search(/{|}/) === -1) {
        return isRuntimeExpression(value)
            ? resolveRuntimeExpression(paramName, value, resolveData, source)
            : value;
    }
    else {
        // Replace link parameters with appropriate values
        const linkParams = value.match(/{([^}]*)}/g);
        linkParams.forEach((linkParam) => {
            value = value.replace(linkParam, resolveRuntimeExpression(paramName, linkParam.substring(1, linkParam.length - 1), resolveData, source));
        });
        return value;
    }
}
/**
 * If the operation type is Query or Mutation, create and return a resolver
 * function that performs API requests for the given GraphQL query
 */
function getResolver({ operation, argsFromLink = {}, payloadName, data, baseUrl, requestOptions, fileUploadOptions, fetch }) {
    // Determine the appropriate URL:
    if (typeof baseUrl === 'undefined') {
        baseUrl = getBaseUrl(operation);
    }
    // Return custom resolver if it is defined
    const customResolvers = data.options.customResolvers;
    const title = operation.oas.info.title;
    const path = operation.path;
    const method = operation.method;
    if (typeof customResolvers === 'object' &&
        typeof customResolvers[title] === 'object' &&
        typeof customResolvers[title][path] === 'object' &&
        typeof customResolvers[title][path][method] === 'function') {
        translationLog$1(`Use custom resolver for ${operation.operationString}`);
        return customResolvers[title][path][method];
    }
    // Return resolve function:
    return async (source, args, context, info) => {
        /**
         * Fetch resolveData from possibly existing _openAPIToGraphQL
         *
         * NOTE: _openAPIToGraphQL is an object used to pass security info and data
         * from previous resolvers
         */
        let resolveData = {};
        if (source &&
            typeof source === 'object' &&
            typeof source[OPENAPI_TO_GRAPHQL] === 'object' &&
            typeof source[OPENAPI_TO_GRAPHQL].data === 'object') {
            const parentIdentifier = getParentIdentifier(info);
            if (!(parentIdentifier.length === 0) &&
                parentIdentifier in source[OPENAPI_TO_GRAPHQL].data) {
                /**
                 * Resolving link params may change the usedParams, but these changes
                 * should not be present in the parent _openAPIToGraphQL, therefore copy
                 * the object
                 */
                resolveData = JSON.parse(JSON.stringify(source[OPENAPI_TO_GRAPHQL].data[parentIdentifier]));
            }
        }
        if (typeof resolveData.usedParams === 'undefined') {
            resolveData.usedParams = {};
        }
        /**
         * Handle default values of parameters, if they have not yet been defined by
         * the user.
         */
        operation.parameters.forEach((param) => {
            const saneParamName = sanitize(param.name, !data.options.simpleNames
                ? CaseStyle.camelCase
                : CaseStyle.simple);
            if (typeof args[saneParamName] === 'undefined' &&
                param.schema &&
                typeof param.schema === 'object') {
                const schemaOrRef = param.schema;
                let schema;
                if ('$ref' in schemaOrRef) {
                    schema = resolveRef(schemaOrRef.$ref, operation.oas);
                }
                else {
                    schema = schemaOrRef;
                }
                if (schema && schema.default && typeof schema.default !== 'undefined') {
                    args[saneParamName] = schema.default;
                }
            }
        });
        // Handle arguments provided by links
        for (const paramName in argsFromLink) {
            const saneParamName = sanitize(paramName, !data.options.simpleNames
                ? CaseStyle.camelCase
                : CaseStyle.simple);
            let value = argsFromLink[paramName];
            args[saneParamName] = inferLinkArguments({
                paramName,
                value,
                resolveData,
                source,
                args
            });
        }
        // Stored used parameters to future requests:
        resolveData.usedParams = Object.assign(resolveData.usedParams, args);
        // Build URL (i.e., fill in path parameters):
        const { path, qs, headers } = extractRequestDataFromArgs(operation.path, operation.parameters, args, data);
        const url = new URL(urljoin(baseUrl, path));
        /**
         * The Content-Type and Accept property should not be changed because the
         * object type has already been created and unlike these properties, it
         * cannot be easily changed
         *
         * NOTE: This may cause the user to encounter unexpected changes
         */
        if (operation.method !== HTTP_METHODS.get) {
            headers['content-type'] =
                typeof operation.payloadContentType !== 'undefined'
                    ? operation.payloadContentType
                    : 'application/json';
        }
        headers['accept'] =
            typeof operation.responseContentType !== 'undefined'
                ? operation.responseContentType
                : 'application/json';
        let options;
        if (requestOptions) {
            options = {
                ...requestOptions,
                method: operation.method,
                headers: {}
            };
            options.headers = {}; // Handle requestOptions.header later if applicable
            if (requestOptions.headers) {
                // requestOptions.headers may be either an object or a function
                if (typeof requestOptions.headers === 'object') {
                    Object.assign(options.headers, headers, requestOptions.headers);
                }
                else if (typeof requestOptions.headers === 'function') {
                    const headers = requestOptions.headers(method, path, title, {
                        source,
                        args,
                        context,
                        info
                    });
                    if (typeof headers === 'object') {
                        Object.assign(options.headers, headers);
                    }
                }
            }
            else {
                options.headers = headers;
            }
            if (typeof requestOptions.qs === 'object') {
                Object.assign(qs, requestOptions.qs);
            }
        }
        else {
            options = {
                method: operation.method,
                headers
            };
        }
        /**
         * Determine possible payload
         *
         * GraphQL produces sanitized payload names, so we have to sanitize before
         * lookup here
         */
        let form;
        resolveData.usedPayload = undefined;
        if (typeof payloadName === 'string') {
            // The option genericPayloadArgName will change the payload name to "requestBody"
            const sanePayloadName = data.options.genericPayloadArgName
                ? 'requestBody'
                : sanitize(payloadName, CaseStyle.camelCase);
            let rawPayload;
            if (operation.payloadContentType === 'application/json') {
                rawPayload = JSON.stringify(desanitizeObjectKeys(args[sanePayloadName], data.saneMap));
            }
            else if (operation.payloadContentType === 'application/x-www-form-urlencoded') {
                rawPayload = formurlencoded(desanitizeObjectKeys(args[sanePayloadName], data.saneMap));
            }
            else if (operation.payloadContentType === 'multipart/form-data') {
                form = new FormData(fileUploadOptions);
                const formFieldsPayloadEntries = Object.entries(args[sanePayloadName]);
                (await Promise.all(formFieldsPayloadEntries.map(([_, v]) => v))).forEach((fieldValue, idx) => {
                    const fieldName = formFieldsPayloadEntries[idx][0];
                    if (typeof fieldValue === 'object' &&
                        Boolean(fieldValue.createReadStream)) {
                        const uploadingFile = fieldValue;
                        const originalFileStream = uploadingFile.createReadStream();
                        const filePassThrough = new stream.PassThrough();
                        originalFileStream.on('readable', function () {
                            let data;
                            while ((data = this.read())) {
                                const canReadNext = filePassThrough.write(data);
                                if (!canReadNext) {
                                    this.pause();
                                    filePassThrough.once('drain', () => this.resume());
                                }
                            }
                        });
                        originalFileStream.on('error', () => {
                            uploadLog('Encountered an error while uploading the file %s', uploadingFile.filename);
                        });
                        originalFileStream.on('end', () => {
                            uploadLog('Upload for received file %s completed', uploadingFile.filename);
                            filePassThrough.end();
                        });
                        uploadLog('Queuing upload for received file %s', uploadingFile.filename);
                        form.append(fieldName, filePassThrough, {
                            filename: uploadingFile.filename,
                            contentType: uploadingFile.mimetype
                        });
                    }
                    else if (typeof fieldValue !== 'string') {
                        // Handle all other primitives that aren't strings as strings the way the web server would expect it
                        form.append(fieldName, JSON.stringify(fieldValue));
                    }
                    else {
                        form.append(fieldName, fieldValue);
                    }
                });
                rawPayload = form;
            }
            else {
                // Payload is not an object
                rawPayload = args[sanePayloadName];
            }
            options.body = rawPayload;
            resolveData.usedPayload = rawPayload;
        }
        /**
         * Pass on OpenAPI-to-GraphQL options
         */
        if (typeof data.options === 'object') {
            // Headers:
            if (typeof data.options.headers === 'object') {
                Object.assign(options.headers, data.options.headers);
            }
            else if (typeof data.options.headers === 'function') {
                const headers = data.options.headers(method, path, title, {
                    source,
                    args,
                    context,
                    info
                });
                if (typeof headers === 'object') {
                    Object.assign(options.headers, headers);
                }
                if (form) {
                    /**
                     * When there is a form, remove default content type and leave
                     * computation of content-type header to fetch
                     *
                     * See https://github.com/github/fetch/issues/505#issuecomment-293064470
                     */
                    Object.assign(options.headers, form.getHeaders());
                    delete options.headers['content-type'];
                }
            }
            // Query string:
            if (typeof data.options.qs === 'object') {
                Object.assign(qs, data.options.qs);
            }
        }
        // Get authentication headers and query parameters
        if (source &&
            typeof source === 'object' &&
            typeof source[OPENAPI_TO_GRAPHQL] === 'object') {
            const { authHeaders, authQs, authCookie } = getAuthOptions(operation, source[OPENAPI_TO_GRAPHQL], data);
            // ...and pass them to the options
            Object.assign(options.headers, authHeaders);
            Object.assign(qs, authQs);
            // Add authentication cookie if created
            if (authCookie !== null) {
                const cookieHeaderName = 'cookie';
                options.headers[cookieHeaderName] = authCookie;
            }
        }
        // Extract OAuth token from context (if available)
        if (data.options.sendOAuthTokenInQuery) {
            const oauthQueryObj = createOAuthQS(data, context);
            Object.assign(qs, oauthQueryObj);
        }
        else {
            const oauthHeader = createOAuthHeader(data, context);
            Object.assign(options.headers, oauthHeader);
        }
        resolveData.usedRequestOptions = options;
        resolveData.usedStatusCode = operation.statusCode;
        setSearchParamsFromObj(url, qs, []);
        resolveData.url = url.toString().replace(url.search, '');
        // Make the call
        httpLog$1(`Call ${options.method.toUpperCase()} ${url.toString()}\n` +
            `headers: ${JSON.stringify(options.headers)}\n` +
            `request body: ${options.body}`);
        let response;
        try {
            response = await fetch(url.toString(), options);
        }
        catch (err) {
            httpLog$1(err);
            throw err;
        }
        const body = await response.text();
        if (response.status < 200 || response.status > 299) {
            httpLog$1(`${response.status} - ${trim(body, 100)}`);
            const errorString = `Could not invoke operation ${operation.operationString}`;
            if (data.options.provideErrorExtensions) {
                let responseBody;
                try {
                    responseBody = JSON.parse(body);
                }
                catch (e) {
                    responseBody = body;
                }
                const extensions = {
                    method: operation.method,
                    path: operation.path,
                    url: url.toString(),
                    statusText: response.statusText,
                    statusCode: response.status,
                    responseHeaders: headersToObject(response.headers),
                    responseBody
                };
                throw graphQLErrorWithExtensions(errorString, extensions);
            }
            else {
                throw new Error(errorString);
            }
            // Successful response code 200-299
        }
        else {
            httpLog$1(`${response.status} - ${trim(body, 100)}`);
            if (response.headers.get('content-type') &&
                operation.responseContentType) {
                /**
                 * Throw warning if the non-application/json content does not
                 * match the OAS.
                 *
                 * Use an inclusion test in case of charset
                 *
                 * i.e. text/plain; charset=utf-8
                 */
                if (!(response.headers
                    .get('content-type')
                    .includes(operation.responseContentType) ||
                    operation.responseContentType.includes(response.headers.get('content-type')))) {
                    const errorString = `Operation ` +
                        `${operation.operationString} ` +
                        `should have a content-type '${operation.responseContentType}' ` +
                        `but has '${response.headers.get('content-type')}' instead`;
                    httpLog$1(errorString);
                    throw new Error(errorString);
                }
                else {
                    /**
                     * If the response body is type JSON, then parse it
                     *
                     * content-type may not be necessarily 'application/json' it can be
                     * 'application/json; charset=utf-8' for example
                     */
                    if (response.headers.get('content-type').includes('application/json')) {
                        let responseBody;
                        try {
                            responseBody = JSON.parse(body);
                        }
                        catch (e) {
                            const errorString = `Cannot JSON parse response body of ` +
                                `operation ${operation.operationString} ` +
                                `even though it has content-type 'application/json'`;
                            httpLog$1(errorString);
                            throw new Error(errorString);
                        }
                        resolveData.responseHeaders = {};
                        response.headers.forEach((val, key) => {
                            resolveData.responseHeaders[key] = val;
                        });
                        // Deal with the fact that the server might send unsanitized data
                        let saneData = sanitizeObjectKeys(responseBody, !data.options.simpleNames
                            ? CaseStyle.camelCase
                            : CaseStyle.simple);
                        // Pass on _openAPIToGraphQL to subsequent resolvers
                        if (saneData && typeof saneData === 'object') {
                            if (Array.isArray(saneData)) {
                                saneData.forEach((element) => {
                                    if (typeof element[OPENAPI_TO_GRAPHQL] === 'undefined') {
                                        element[OPENAPI_TO_GRAPHQL] = {
                                            data: {}
                                        };
                                    }
                                    if (source &&
                                        typeof source === 'object' &&
                                        typeof source[OPENAPI_TO_GRAPHQL] === 'object') {
                                        Object.assign(element[OPENAPI_TO_GRAPHQL], source[OPENAPI_TO_GRAPHQL]);
                                    }
                                    element[OPENAPI_TO_GRAPHQL].data[getIdentifier(info)] =
                                        resolveData;
                                });
                            }
                            else {
                                if (typeof saneData[OPENAPI_TO_GRAPHQL] === 'undefined') {
                                    saneData[OPENAPI_TO_GRAPHQL] = {
                                        data: {}
                                    };
                                }
                                if (source &&
                                    typeof source === 'object' &&
                                    typeof source[OPENAPI_TO_GRAPHQL] === 'object') {
                                    Object.assign(saneData[OPENAPI_TO_GRAPHQL], source[OPENAPI_TO_GRAPHQL]);
                                }
                                saneData[OPENAPI_TO_GRAPHQL].data[getIdentifier(info)] =
                                    resolveData;
                            }
                        }
                        // Apply limit argument
                        if (data.options.addLimitArgument &&
                            /**
                             * NOTE: Does not differentiate between autogenerated args and
                             * preexisting args
                             *
                             * Ensure that there is not preexisting 'limit' argument
                             */
                            !operation.parameters.find((parameter) => {
                                return parameter.name === 'limit';
                            }) &&
                            // Only array data
                            Array.isArray(saneData) &&
                            // Only array of objects/arrays
                            saneData.some((data) => {
                                return typeof data === 'object';
                            })) {
                            let arraySaneData = saneData;
                            if ('limit' in args && typeof args['limit'] === 'number') {
                                const limit = args['limit'];
                                if (limit >= 0) {
                                    arraySaneData = arraySaneData.slice(0, limit);
                                }
                                else {
                                    throw new Error(`Auto-generated 'limit' argument must be greater than or equal to 0`);
                                }
                            }
                            else {
                                throw new Error(`Cannot get value for auto-generated 'limit' argument`);
                            }
                            saneData = arraySaneData;
                        }
                        return saneData;
                    }
                    else {
                        // TODO: Handle YAML
                        return body;
                    }
                }
            }
            else {
                /**
                 * Check to see if there is not supposed to be a response body,
                 * if that is the case, that would explain why there is not
                 * a content-type
                 */
                if (typeof operation.responseContentType !== 'string') {
                    return null;
                }
                else {
                    const errorString = 'Response does not have a Content-Type header';
                    httpLog$1(errorString);
                    throw new Error(errorString);
                }
            }
        }
    };
}
function headersToObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}
/**
 * Attempts to create an object to become an OAuth query string by extracting an
 * OAuth token from the context based on the JSON path provided in the options.
 */
function createOAuthQS(data, context) {
    return typeof data.options.tokenJSONpath !== 'string'
        ? {}
        : extractToken(data, context);
}
function extractToken(data, context) {
    const tokenJSONpath = data.options.tokenJSONpath;
    const tokens = JSONPath({
        path: tokenJSONpath,
        json: context
    });
    if (Array.isArray(tokens) && tokens.length > 0) {
        const token = tokens[0];
        return {
            access_token: token
        };
    }
    else {
        httpLog$1(`Warning: could not extract OAuth token from context at '${tokenJSONpath}'`);
        return {};
    }
}
/**
 * Attempts to create an OAuth authorization header by extracting an OAuth token
 * from the context based on the JSON path provided in the options.
 */
function createOAuthHeader(data, context) {
    if (typeof data.options.tokenJSONpath !== 'string') {
        return {};
    }
    // Extract token
    const tokenJSONpath = data.options.tokenJSONpath;
    const tokens = JSONPath({
        path: tokenJSONpath,
        json: context
    });
    if (Array.isArray(tokens) && tokens.length > 0) {
        const token = tokens[0];
        return {
            Authorization: `Bearer ${token}`,
            'User-Agent': 'openapi-to-graphql'
        };
    }
    else {
        httpLog$1(`Warning: could not extract OAuth token from context at ` +
            `'${tokenJSONpath}'`);
        return {};
    }
}
/**
 * Return the headers and query strings to authenticate a request (if any).
 * Return authHeader and authQs, which hold headers and query parameters
 * respectively to authentication a request.
 */
function getAuthOptions(operation, _openAPIToGraphQL, data) {
    const authHeaders = {};
    const authQs = {};
    let authCookie = null;
    /**
     * Determine if authentication is required, and which protocol (if any) we can
     * use
     */
    const { authRequired, securityRequirement, sanitizedSecurityRequirement } = getAuthReqAndProtcolName(operation, _openAPIToGraphQL);
    // Possibly, we don't need to do anything:
    if (!authRequired) {
        return { authHeaders, authQs, authCookie };
    }
    // If authentication is required, but we can't fulfill the protocol, throw:
    if (authRequired && typeof securityRequirement !== 'string') {
        throw new Error(`Missing information to authenticate API request.`);
    }
    if (typeof securityRequirement === 'string') {
        const security = data.security[securityRequirement];
        switch (security.def.type) {
            case 'apiKey':
                const apiKey = _openAPIToGraphQL.security[sanitizedSecurityRequirement].apiKey;
                if ('in' in security.def) {
                    if (typeof security.def.name === 'string') {
                        if (security.def.in === 'header') {
                            authHeaders[security.def.name] = apiKey;
                        }
                        else if (security.def.in === 'query') {
                            authQs[security.def.name] = apiKey;
                        }
                        else if (security.def.in === 'cookie') {
                            authCookie = `${security.def.name}=${apiKey}`;
                        }
                    }
                    else {
                        throw new Error(`Cannot send API key in '${JSON.stringify(security.def.in)}'`);
                    }
                }
                break;
            case 'http':
                switch (security.def.scheme) {
                    case 'basic':
                        const username = _openAPIToGraphQL.security[sanitizedSecurityRequirement].username;
                        const password = _openAPIToGraphQL.security[sanitizedSecurityRequirement].password;
                        const credentials = `${username}:${password}`;
                        authHeaders['Authorization'] = `Basic ${Buffer.from(credentials).toString('base64')}`;
                        break;
                    case 'bearer':
                        const token = _openAPIToGraphQL.security[sanitizedSecurityRequirement].token;
                        authHeaders['Authorization'] = `Bearer ${token}`;
                        break;
                    default:
                        throw new Error(`Cannot recognize http security scheme ` +
                            `'${JSON.stringify(security.def.scheme)}'`);
                }
                break;
            case 'oauth2':
                break;
            case 'openIdConnect':
                break;
            default:
                throw new Error(`Cannot recognize security type '${security.def.type}'`);
        }
    }
    return { authHeaders, authQs, authCookie };
}
/**
 * Determines whether a given operation requires authentication, and which of
 * the (possibly multiple) authentication protocols can be used based on the
 * data present in the given context.
 */
function getAuthReqAndProtcolName(operation, _openAPIToGraphQL) {
    let authRequired = false;
    if (Array.isArray(operation.securityRequirements) &&
        operation.securityRequirements.length > 0) {
        authRequired = true;
        for (let securityRequirement of operation.securityRequirements) {
            const sanitizedSecurityRequirement = sanitize(securityRequirement, CaseStyle.camelCase);
            if (typeof _openAPIToGraphQL.security[sanitizedSecurityRequirement] ===
                'object') {
                return {
                    authRequired,
                    securityRequirement,
                    sanitizedSecurityRequirement
                };
            }
        }
    }
    return {
        authRequired
    };
}
/**
 * Given a link parameter or callback path, determine the value from the runtime
 * expression
 *
 * The link parameter or callback path is a reference to data contained in the
 * url/method/statuscode or response/request body/query/path/header
 */
function resolveRuntimeExpression(paramName, runtimeExpression, resolveData, root, args) {
    if (runtimeExpression === '$url') {
        return resolveData.url;
    }
    else if (runtimeExpression === '$method') {
        return resolveData.usedRequestOptions.method;
    }
    else if (runtimeExpression === '$statusCode') {
        return resolveData.usedStatusCode;
    }
    else if (runtimeExpression.startsWith('$request.')) {
        // CASE: parameter is previous body
        if (runtimeExpression === '$request.body') {
            return resolveData.usedPayload;
            // CASE: parameter in previous body
        }
        else if (runtimeExpression.startsWith('$request.body#')) {
            const tokens = JSONPath({
                path: runtimeExpression.split('body#/')[1],
                json: resolveData.usedPayload
            });
            if (Array.isArray(tokens) && tokens.length > 0) {
                return tokens[0];
            }
            else {
                httpLog$1(`Warning: could not extract parameter '${paramName}' from link`);
            }
            // CASE: parameter in previous query parameter
        }
        else if (runtimeExpression.startsWith('$request.query')) {
            return resolveData.usedParams[sanitize(runtimeExpression.split('query.')[1], CaseStyle.camelCase)];
            // CASE: parameter in previous path parameter
        }
        else if (runtimeExpression.startsWith('$request.path')) {
            return resolveData.usedParams[sanitize(runtimeExpression.split('path.')[1], CaseStyle.camelCase)];
            // CASE: parameter in previous header parameter
        }
        else if (runtimeExpression.startsWith('$request.header')) {
            return resolveData.usedRequestOptions.headers[runtimeExpression.split('header.')[1]];
        }
    }
    else if (runtimeExpression.startsWith('$response.')) {
        /**
         * CASE: parameter is body
         *
         * NOTE: may not be used because it implies that the operation does not
         * return a JSON object and OpenAPI-to-GraphQL does not create GraphQL
         * objects for non-JSON data and links can only exists between objects.
         */
        if (runtimeExpression === '$response.body') {
            const result = JSON.parse(JSON.stringify(root));
            /**
             * _openAPIToGraphQL contains data used by OpenAPI-to-GraphQL to create the GraphQL interface
             * and should not be exposed
             */
            result._openAPIToGraphQL = undefined;
            return result;
            // CASE: parameter in body
        }
        else if (runtimeExpression.startsWith('$response.body#')) {
            return get(root, runtimeExpression.split('body#')[1]);
            // CASE: parameter in query parameter
        }
        else if (runtimeExpression.startsWith('$response.query')) {
            // NOTE: handled the same way $request.query is handled
            return resolveData.usedParams[sanitize(runtimeExpression.split('query.')[1], CaseStyle.camelCase)];
            // CASE: parameter in path parameter
        }
        else if (runtimeExpression.startsWith('$response.path')) {
            // NOTE: handled the same way $request.path is handled
            return resolveData.usedParams[sanitize(runtimeExpression.split('path.')[1], CaseStyle.camelCase)];
            // CASE: parameter in header parameter
        }
        else if (runtimeExpression.startsWith('$response.header')) {
            return resolveData.responseHeaders[runtimeExpression.split('header.')[1]];
        }
    }
    throw new Error(`Cannot resolve link because '${runtimeExpression}' is an invalid runtime expression.`);
}
/**
 * Check if a string is a runtime expression in the context of link parameters
 */
function isRuntimeExpression(str) {
    if (str === '$url' || str === '$method' || str === '$statusCode') {
        return true;
    }
    else if (str.startsWith('$request.')) {
        for (let i = 0; i < RUNTIME_REFERENCES.length; i++) {
            if (str.startsWith(`$request.${RUNTIME_REFERENCES[i]}`)) {
                return true;
            }
        }
    }
    else if (str.startsWith('$response.')) {
        for (let i = 0; i < RUNTIME_REFERENCES.length; i++) {
            if (str.startsWith(`$response.${RUNTIME_REFERENCES[i]}`)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * From the info object provided by the resolver, get a unique identifier, which
 * is the path formed from the nested field names (or aliases if provided)
 *
 * Used to store and retrieve the _openAPIToGraphQL of parent field
 */
function getIdentifier(info) {
    return getIdentifierRecursive(info.path);
}
/**
 * From the info object provided by the resolver, get the unique identifier of
 * the parent object
 */
function getParentIdentifier(info) {
    return getIdentifierRecursive(info.path.prev);
}
/**
 * Get the path of nested field names (or aliases if provided)
 */
function getIdentifierRecursive(path) {
    return typeof path.prev === 'undefined'
        ? path.key
        : /**
         * Check if the identifier contains array indexing, if so remove.
         *
         * i.e. instead of 0/friends/1/friends/2/friends/user, create
         * friends/friends/friends/user
         */
            isNaN(parseInt(path.key))
                ? `${path.key}/${getIdentifierRecursive(path.prev)}`
                : getIdentifierRecursive(path.prev);
}
/**
 * Create a new GraphQLError with an extensions field
 */
function graphQLErrorWithExtensions(message, extensions) {
    return new GraphQLError(message, null, null, null, null, null, extensions);
}
/**
 * Extracts data from the GraphQL arguments of a particular field
 *
 * Replaces the path parameter in the given path with values in the given args.
 * Furthermore adds the query parameters for a request.
 */
function extractRequestDataFromArgs(path, parameters, args, // NOTE: argument keys are sanitized!
data) {
    const qs = {};
    const headers = {};
    // Iterate parameters:
    for (const param of parameters) {
        const saneParamName = sanitize(param.name, !data.options.simpleNames
            ? CaseStyle.camelCase
            : CaseStyle.simple);
        if (saneParamName && saneParamName in args) {
            switch (param.in) {
                // Path parameters
                case 'path':
                    path = path.replace(`{${param.name}}`, args[saneParamName]);
                    break;
                // Query parameters
                case 'query':
                    // setting param style as form assumes explode is true by default
                    if (param.style === 'form' &&
                        typeof args[saneParamName] === 'object') {
                        if (param.explode === false) {
                            qs[param.name] = Object.entries(args[saneParamName]).reduce((acc, val) => {
                                acc += val.join(',');
                                return acc;
                            }, '');
                        }
                        else {
                            Object.entries(args[saneParamName]).forEach(([key, value]) => {
                                qs[key] = value;
                            });
                        }
                    }
                    else if (Array.isArray(args[saneParamName]) &&
                        param.style === 'form' &&
                        param.explode !== false) {
                        qs[param.name] = args[saneParamName].join(',');
                    }
                    else {
                        qs[param.name] = args[saneParamName];
                    }
                    break;
                // Header parameters
                case 'header':
                    headers[param.name] = args[saneParamName];
                    break;
                // Cookie parameters
                case 'cookie':
                    if (!('cookie' in headers)) {
                        headers['cookie'] = '';
                    }
                    headers['cookie'] += `${param.name}=${args[saneParamName]}; `;
                    break;
                default:
                    httpLog$1(`Warning: The parameter location '${param.in}' in the ` +
                        `parameter '${param.name}' of operation '${path}' is not ` +
                        `supported`);
            }
        }
    }
    return { path, qs, headers };
}
const setSearchParamsFromObj = (url, obj, path) => {
    for (const key in obj) {
        const val = obj[key];
        const newPath = [...path, key];
        if (typeof val === 'object') {
            setSearchParamsFromObj(url, val, newPath);
        }
        else {
            const finalKey = newPath.reduce((acc, pathElem, i) => (i === 0 ? pathElem : `${acc}[${pathElem}]`), '');
            url.searchParams.set(finalKey, val);
        }
    }
};

// Copyright IBM Corp. 2018. All Rights Reserved.
const preprocessingLog$1 = debug('preprocessing');
/**
 * Given an operation object from the OAS, create an Operation, which contains
 * the necessary data to create a GraphQL wrapper for said operation object.
 *
 * @param path The path of the operation object
 * @param method The method of the operation object
 * @param operationString A string representation of the path and the method (and the OAS title if applicable)
 * @param operationType Whether the operation should be turned into a Query/Mutation/Subscription operation
 * @param operation The operation object from the OAS
 * @param pathItem The path item object from the OAS from which the operation object is derived from
 * @param oas The OAS from which the path item and operation object are derived from
 * @param data An assortment of data which at this point is mainly used enable logging
 * @param options The options passed by the user
 */
function processOperation(path, method, operationString, operationType, operation, pathItem, oas, data, options) {
    // Response schema
    const { responseContentType, responseSchema, responseSchemaNames, statusCode } = getResponseSchemaAndNames(path, method, operation, oas, data, options);
    /**
     * All GraphQL fields must have a type, which is derived from the response
     * schema. Therefore, the response schema is the first to be determined.
     */
    if (typeof responseSchema === 'object') {
        // Description
        let description = operation.description;
        if ((typeof description !== 'string' || description === '') &&
            typeof operation.summary === 'string') {
            description = operation.summary;
        }
        if (data.options.equivalentToMessages) {
            // Description may not exist
            if (typeof description !== 'string') {
                description = `Equivalent to ${operationString}`;
            }
            else {
                description += `\n\nEquivalent to ${operationString}`;
            }
        }
        // Tags
        const tags = operation.tags || [];
        // OperationId
        const operationId = typeof operation.operationId !== 'undefined'
            ? operation.operationId
            : generateOperationId(method, path);
        // Request schema
        const { payloadContentType, payloadSchema, payloadSchemaNames, payloadRequired } = getRequestSchemaAndNames(path, method, operation, oas);
        // Request data definition
        const payloadDefinition = payloadSchema && typeof payloadSchema !== 'undefined'
            ? createDataDef(payloadSchemaNames, payloadSchema, true, data, oas)
            : undefined;
        // Links
        const links = getLinks(path, method, operation, oas, data);
        // Response data definition
        const responseDefinition = createDataDef(responseSchemaNames, responseSchema, false, data, oas, links);
        // Parameters
        const parameters = getParameters(path, method, operation, pathItem, oas);
        // Security protocols
        const securityRequirements = options.viewer
            ? getSecurityRequirements(operation, data.security, oas)
            : [];
        // Servers
        const servers = getServers(operation, pathItem, oas);
        // Whether to place this operation into an authentication viewer
        const inViewer = securityRequirements.length > 0 && data.options.viewer !== false;
        return {
            operation,
            operationId,
            operationString,
            operationType,
            description,
            tags,
            path,
            method,
            payloadContentType,
            payloadDefinition,
            payloadRequired,
            responseContentType,
            responseDefinition,
            parameters,
            securityRequirements,
            servers,
            inViewer,
            statusCode,
            oas
        };
    }
    else {
        handleWarning({
            mitigationType: MitigationTypes.MISSING_RESPONSE_SCHEMA,
            message: `Operation ${operationString} has no (valid) response schema. ` +
                `You can use the fillEmptyResponses option to create a ` +
                `placeholder schema`,
            data,
            log: preprocessingLog$1
        });
    }
}
/**
 * Extract information from the OAS and put it inside a data structure that
 * is easier for OpenAPI-to-GraphQL to use
 */
function preprocessOas(oass, options) {
    const data = {
        operations: {},
        callbackOperations: {},
        usedTypeNames: [
            'Query',
            'Mutation',
            'Subscription' // Used by OpenAPI-to-GraphQL for root-level element
        ],
        defs: [],
        security: {},
        saneMap: {},
        options,
        oass
    };
    oass.forEach((oas) => {
        // Store stats on OAS:
        data.options.report.numOps += countOperations(oas);
        data.options.report.numOpsMutation += countOperationsMutation(oas);
        data.options.report.numOpsQuery += countOperationsQuery(oas);
        if (data.options.createSubscriptionsFromCallbacks) {
            data.options.report.numOpsSubscription += countOperationsSubscription(oas);
        }
        else {
            data.options.report.numOpsSubscription = 0;
        }
        // Get security schemes
        const currentSecurity = getProcessedSecuritySchemes(oas, data);
        const commonSecurityPropertyName = getCommonPropertyNames(data.security, currentSecurity);
        commonSecurityPropertyName.forEach((propertyName) => {
            handleWarning({
                mitigationType: MitigationTypes.DUPLICATE_SECURITY_SCHEME,
                message: `Multiple OASs share security schemes with the same name '${propertyName}'`,
                mitigationAddendum: `The security scheme from OAS ` +
                    `'${currentSecurity[propertyName].oas.info.title}' will be ignored`,
                data,
                log: preprocessingLog$1
            });
        });
        // Do not overwrite preexisting security schemes
        data.security = { ...currentSecurity, ...data.security };
        // Process all operations
        for (let path in oas.paths) {
            const pathItem = typeof oas.paths[path].$ref === 'string'
                ? resolveRef(oas.paths[path].$ref, oas)
                : oas.paths[path];
            Object.keys(pathItem)
                .filter((pathFields) => {
                /**
                 * Get only method fields that contain operation objects (e.g. "get",
                 * "put", "post", "delete", etc.)
                 *
                 * Can also contain other fields such as summary or description
                 */
                return isHttpMethod(pathFields);
            })
                .forEach((rawMethod) => {
                var _a, _b, _c;
                const operationString = oass.length === 1
                    ? formatOperationString(rawMethod, path)
                    : formatOperationString(rawMethod, path, oas.info.title);
                let httpMethod;
                try {
                    httpMethod = methodToHttpMethod(rawMethod);
                }
                catch (e) {
                    handleWarning({
                        mitigationType: MitigationTypes.INVALID_HTTP_METHOD,
                        message: `Invalid HTTP method '${rawMethod}' in operation '${operationString}'`,
                        data,
                        log: preprocessingLog$1
                    });
                    return;
                }
                const operation = pathItem[httpMethod];
                let operationType = httpMethod === HTTP_METHODS.get
                    ? GraphQLOperationType.Query
                    : GraphQLOperationType.Mutation;
                // Option selectQueryOrMutationField can override operation type
                if (typeof ((_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.selectQueryOrMutationField) === null || _a === void 0 ? void 0 : _a[oas.info.title]) === null || _b === void 0 ? void 0 : _b[path]) === null || _c === void 0 ? void 0 : _c[httpMethod]) === 'number'
                // This is an enum, which is an integer value
                ) {
                    operationType =
                        options.selectQueryOrMutationField[oas.info.title][path][httpMethod] === GraphQLOperationType.Mutation
                            ? GraphQLOperationType.Mutation
                            : GraphQLOperationType.Query;
                }
                const operationData = processOperation(path, httpMethod, operationString, operationType, operation, pathItem, oas, data, options);
                if (typeof operationData === 'object') {
                    /**
                     * Handle operationId property name collision
                     * May occur if multiple OAS are provided
                     */
                    if (!(operationData.operationId in data.operations)) {
                        data.operations[operationData.operationId] = operationData;
                    }
                    else {
                        handleWarning({
                            mitigationType: MitigationTypes.DUPLICATE_OPERATIONID,
                            message: `Multiple OASs share operations with the same operationId '${operationData.operationId}'`,
                            mitigationAddendum: `The operation from the OAS '${operationData.oas.info.title}' will be ignored`,
                            data,
                            log: preprocessingLog$1
                        });
                        return;
                    }
                }
                // Process all callbacks
                if (data.options.createSubscriptionsFromCallbacks &&
                    operation.callbacks) {
                    Object.entries(operation.callbacks).forEach(([callbackName, callbackObjectOrRef]) => {
                        let callback;
                        if ('$ref' in callbackObjectOrRef &&
                            typeof callbackObjectOrRef.$ref === 'string') {
                            callback = resolveRef(callbackObjectOrRef.$ref, oas);
                        }
                        else {
                            callback = callbackObjectOrRef;
                        }
                        Object.entries(callback).forEach(([callbackExpression, callbackPathItem]) => {
                            const resolvedCallbackPathItem = !('$ref' in callbackPathItem)
                                ? callbackPathItem
                                : resolveRef(callbackPathItem.$ref, oas);
                            const callbackOperationObjectMethods = Object.keys(resolvedCallbackPathItem).filter((objectKey) => {
                                /**
                                 * Get only fields that contain operation objects
                                 *
                                 * Can also contain other fields such as summary or description
                                 */
                                return isHttpMethod(objectKey);
                            });
                            if (callbackOperationObjectMethods.length > 0) {
                                if (callbackOperationObjectMethods.length > 1) {
                                    handleWarning({
                                        mitigationType: MitigationTypes.CALLBACKS_MULTIPLE_OPERATION_OBJECTS,
                                        message: `Callback '${callbackExpression}' on operation '${operationString}' has multiple operation objects with the methods '${callbackOperationObjectMethods}'. OpenAPI-to-GraphQL can only utilize one of these operation objects.`,
                                        mitigationAddendum: `The operation with the method '${callbackOperationObjectMethods[0]}' will be selected and all others will be ignored.`,
                                        data,
                                        log: preprocessingLog$1
                                    });
                                }
                                // Select only one of the operation object methods
                                const callbackRawMethod = callbackOperationObjectMethods[0];
                                const callbackOperationString = oass.length === 1
                                    ? formatOperationString(httpMethod, callbackName)
                                    : formatOperationString(httpMethod, callbackName, oas.info.title);
                                let callbackHttpMethod;
                                try {
                                    callbackHttpMethod = methodToHttpMethod(callbackRawMethod);
                                }
                                catch (e) {
                                    handleWarning({
                                        mitigationType: MitigationTypes.INVALID_HTTP_METHOD,
                                        message: `Invalid HTTP method '${rawMethod}' in callback '${callbackOperationString}' in operation '${operationString}'`,
                                        data,
                                        log: preprocessingLog$1
                                    });
                                    return;
                                }
                                const callbackOperation = processOperation(callbackExpression, callbackHttpMethod, callbackOperationString, GraphQLOperationType.Subscription, resolvedCallbackPathItem[callbackHttpMethod], callbackPathItem, oas, data, options);
                                if (callbackOperation) {
                                    /**
                                     * Handle operationId property name collision
                                     * May occur if multiple OAS are provided
                                     */
                                    if (callbackOperation &&
                                        !(callbackOperation.operationId in
                                            data.callbackOperations)) {
                                        data.callbackOperations[callbackOperation.operationId] = callbackOperation;
                                    }
                                    else {
                                        handleWarning({
                                            mitigationType: MitigationTypes.DUPLICATE_OPERATIONID,
                                            message: `Multiple OASs share callback operations with the same operationId '${callbackOperation.operationId}'`,
                                            mitigationAddendum: `The callback operation from the OAS '${operationData.oas.info.title}' will be ignored`,
                                            data,
                                            log: preprocessingLog$1
                                        });
                                    }
                                }
                            }
                        });
                    });
                }
            });
        }
    });
    return data;
}
/**
 * Extracts the security schemes from given OAS and organizes the information in
 * a data structure that is easier for OpenAPI-to-GraphQL to use
 *
 * Here is the structure of the data:
 * {
 *   {string} [sanitized name] { Contains information about the security protocol
 *     {string} rawName           Stores the raw security protocol name
 *     {object} def               Definition provided by OAS
 *     {object} parameters        Stores the names of the authentication credentials
 *                                  NOTE: Structure will depend on the type of the protocol
 *                                    (e.g. basic authentication, API key, etc.)
 *                                  NOTE: Mainly used for the AnyAuth viewers
 *     {object} schema            Stores the GraphQL schema to create the viewers
 *   }
 * }
 *
 * Here is an example:
 * {
 *   MyApiKey: {
 *     rawName: "My_api_key",
 *     def: { ... },
 *     parameters: {
 *       apiKey: MyKeyApiKey
 *     },
 *     schema: { ... }
 *   }
 *   MyBasicAuth: {
 *     rawName: "My_basic_auth",
 *     def: { ... },
 *     parameters: {
 *       username: MyBasicAuthUsername,
 *       password: MyBasicAuthPassword,
 *     },
 *     schema: { ... }
 *   }
 * }
 */
function getProcessedSecuritySchemes(oas, data) {
    const result = {};
    const security = getSecuritySchemes(oas);
    // Loop through all the security protocols
    for (let schemeKey in security) {
        const securityScheme = security[schemeKey];
        // Determine the schema and the parameters for the security protocol
        let schema;
        let parameters = {};
        let description;
        switch (securityScheme.type) {
            case 'apiKey':
                description = `API key credentials for the security protocol '${schemeKey}'`;
                if (data.oass.length > 1) {
                    description += ` in ${oas.info.title}`;
                }
                parameters = {
                    apiKey: sanitize(`${schemeKey}_apiKey`, CaseStyle.camelCase)
                };
                schema = {
                    type: 'object',
                    description,
                    properties: {
                        apiKey: {
                            type: 'string'
                        }
                    }
                };
                break;
            case 'http':
                switch (securityScheme.scheme) {
                    /**
                     * TODO: HTTP has a number of authentication types
                     *
                     * See http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
                     */
                    case 'basic':
                        description = `Basic auth credentials for security protocol '${schemeKey}'`;
                        parameters = {
                            username: sanitize(`${schemeKey}_username`, CaseStyle.camelCase),
                            password: sanitize(`${schemeKey}_password`, CaseStyle.camelCase)
                        };
                        schema = {
                            type: 'object',
                            description,
                            properties: {
                                username: {
                                    type: 'string'
                                },
                                password: {
                                    type: 'string'
                                }
                            }
                        };
                        break;
                    case 'bearer':
                        description = `Bearer auth credentials for security protocol '${schemeKey}'`;
                        parameters = {
                            token: sanitize(`${schemeKey}_token`, CaseStyle.camelCase)
                        };
                        schema = {
                            type: 'object',
                            description,
                            properties: {
                                token: {
                                    type: 'string'
                                }
                            }
                        };
                        break;
                    default:
                        handleWarning({
                            mitigationType: MitigationTypes.UNSUPPORTED_HTTP_SECURITY_SCHEME,
                            message: `Currently unsupported HTTP authentication protocol ` +
                                `type 'http' and scheme '${securityScheme.scheme}' in OAS ` +
                                `'${oas.info.title}'`,
                            data,
                            log: preprocessingLog$1
                        });
                }
                break;
            // TODO: Implement
            case 'openIdConnect':
                handleWarning({
                    mitigationType: MitigationTypes.UNSUPPORTED_HTTP_SECURITY_SCHEME,
                    message: `Currently unsupported HTTP authentication protocol ` +
                        `type 'openIdConnect' in OAS '${oas.info.title}'`,
                    data,
                    log: preprocessingLog$1
                });
                break;
            case 'oauth2':
                handleWarning({
                    mitigationType: MitigationTypes.OAUTH_SECURITY_SCHEME,
                    message: `OAuth security scheme found in OAS '${oas.info.title}'`,
                    data,
                    log: preprocessingLog$1
                });
                // Continue because we do not want to create an OAuth viewer
                continue;
            default:
                handleWarning({
                    mitigationType: MitigationTypes.UNSUPPORTED_HTTP_SECURITY_SCHEME,
                    message: `Unsupported HTTP authentication protocol` +
                        `type '${securityScheme.type}' in OAS '${oas.info.title}'`,
                    data,
                    log: preprocessingLog$1
                });
        }
        // Add protocol data to the output
        result[schemeKey] = {
            rawName: schemeKey,
            def: securityScheme,
            parameters,
            schema,
            oas
        };
    }
    return result;
}
/**
 * Method to either create a new or reuse an existing, centrally stored data
 * definition.
 */
function createDataDef(names, schemaOrRef, isInputObjectType, data, oas, links) {
    const preferredName = getPreferredName(names);
    // Basic validation test
    if (typeof schemaOrRef !== 'object' && schemaOrRef !== null) {
        handleWarning({
            mitigationType: MitigationTypes.MISSING_SCHEMA,
            message: `Could not create data definition for schema with ` +
                `preferred name '${preferredName}' and schema '${JSON.stringify(schemaOrRef)}'`,
            data,
            log: preprocessingLog$1
        });
        return {
            preferredName,
            schema: null,
            required: [],
            links: null,
            subDefinitions: null,
            graphQLTypeName: null,
            graphQLInputObjectTypeName: null,
            targetGraphQLType: TargetGraphQLType.json
        };
    }
    let schema;
    if ('$ref' in schemaOrRef && typeof schemaOrRef.$ref === 'string') {
        schema = resolveRef(schemaOrRef.$ref, oas);
    }
    else {
        schema = schemaOrRef;
    }
    // Sanitize link keys
    const saneLinks = sanitizeLinks({ links, data });
    // Check for preexisting data definition
    const index = getSchemaIndex(preferredName, schema, data.defs);
    if (index !== -1) {
        // Found existing data definition and fetch it
        const existingDataDef = data.defs[index];
        /**
         * Special handling for oneOf. Subdefinitions are always an array
         * (see createOneOfUnion)
         */
        if (existingDataDef.targetGraphQLType === TargetGraphQLType.oneOfUnion &&
            Array.isArray(existingDataDef.subDefinitions)) {
            existingDataDef.subDefinitions.forEach((def) => {
                collapseLinksIntoDataDefinition({
                    additionalLinks: saneLinks,
                    existingDataDef: def,
                    data,
                });
            });
        }
        else {
            collapseLinksIntoDataDefinition({
                additionalLinks: saneLinks,
                existingDataDef,
                data,
            });
        }
        return existingDataDef;
    }
    // There is no preexisting data definition, so create a new one
    const name = getSchemaName(names, data.usedTypeNames);
    let saneInputName;
    let saneName;
    if (name === names.fromExtension) {
        saneName = name;
        saneInputName = name + 'Input';
    }
    else {
        // Store and sanitize the name
        saneName = !data.options.simpleNames
            ? sanitize(name, CaseStyle.PascalCase)
            : capitalize(sanitize(name, CaseStyle.simple));
        saneInputName = capitalize(saneName + 'Input');
    }
    storeSaneName(saneName, name, data.saneMap);
    /**
     * Recursively resolve allOf so type, properties, anyOf, oneOf, and
     * required are resolved
     */
    const collapsedSchema = resolveAllOf(schema, {}, data, oas);
    const targetGraphQLType = getSchemaTargetGraphQLType(collapsedSchema, data, oas);
    const def = {
        preferredName,
        /**
         * Note that schema may contain $ref or schema composition (e.g. allOf)
         *
         * TODO: the schema is used in getSchemaIndex, which allows us to check
         * whether a dataDef has already been created for that particular
         * schema and name pair. The look up should resolve references but
         * currently, it does not.
         */
        schema,
        required: [],
        targetGraphQLType,
        subDefinitions: undefined,
        links: saneLinks,
        graphQLTypeName: saneName,
        graphQLInputObjectTypeName: saneInputName
    };
    // Used type names and defs of union and object types are pushed during creation
    if (targetGraphQLType === TargetGraphQLType.object ||
        targetGraphQLType === TargetGraphQLType.list ||
        targetGraphQLType === TargetGraphQLType.enum) {
        data.usedTypeNames.push(saneName);
        data.usedTypeNames.push(saneInputName);
        // Add the def to the master list
        data.defs.push(def);
    }
    switch (targetGraphQLType) {
        case TargetGraphQLType.object:
            def.subDefinitions = {};
            if (typeof collapsedSchema.properties === 'object' &&
                Object.keys(collapsedSchema.properties).length > 0) {
                addObjectPropertiesToDataDef(def, collapsedSchema, def.required, isInputObjectType, data, oas);
            }
            else {
                handleWarning({
                    mitigationType: MitigationTypes.OBJECT_MISSING_PROPERTIES,
                    message: `Schema ${JSON.stringify(schema)} does not have ` +
                        `any properties`,
                    data,
                    log: preprocessingLog$1
                });
                def.targetGraphQLType = TargetGraphQLType.json;
            }
            break;
        case TargetGraphQLType.list:
            if (typeof collapsedSchema.items === 'object') {
                // Break schema down into component parts
                // I.e. if it is an list type, create a reference to the list item type
                // Or if it is an object type, create references to all of the field types
                let itemsSchema = collapsedSchema.items;
                let itemsName = `${name}ListItem`;
                if ('$ref' in itemsSchema) {
                    itemsName = itemsSchema.$ref.split('/').pop();
                }
                const extensionTypeName = collapsedSchema[OAS_GRAPHQL_EXTENSIONS.TypeName];
                const subDefinition = createDataDef(
                // Is this the correct classification for this name? It does not matter in the long run.
                {
                    fromExtension: extensionTypeName,
                    fromRef: itemsName
                }, itemsSchema, isInputObjectType, data, oas);
                // Add list item reference
                def.subDefinitions = subDefinition;
            }
            break;
        case TargetGraphQLType.anyOfObject:
            if (Array.isArray(collapsedSchema.anyOf)) {
                /**
                 * Sanity check
                 *
                 * Determining the targetGraphQLType should have checked the presence
                 * of anyOf
                 */
                createAnyOfObject(saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas);
            }
            else {
                throw new Error(`OpenAPI-to-GraphQL error: Cannot create object ` +
                    `from anyOf because there is no anyOf in ` +
                    `schema '${JSON.stringify(schemaOrRef, null, 2)}'`);
            }
            break;
        case TargetGraphQLType.oneOfUnion:
            /**
             * Sanity check
             *
             * Determining the targetGraphQLType should have checked the presence
             * of oneOf
             */
            if (Array.isArray(collapsedSchema.oneOf)) {
                createOneOfUnion(saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas);
            }
            else {
                throw new Error(`OpenAPI-to-GraphQL error: Cannot create union ` +
                    `from oneOf because there is no oneOf in ` +
                    `schema '${JSON.stringify(schemaOrRef, null, 2)}'`);
            }
            break;
        case TargetGraphQLType.json:
            def.targetGraphQLType = TargetGraphQLType.json;
            break;
        case null:
            // No target GraphQL type
            handleWarning({
                mitigationType: MitigationTypes.UNKNOWN_TARGET_TYPE,
                message: `No GraphQL target type could be identified for schema '${JSON.stringify(schema)}'.`,
                data,
                log: preprocessingLog$1
            });
            def.targetGraphQLType = TargetGraphQLType.json;
            break;
    }
    return def;
}
/**
 * Returns the index of the data definition object in the given list that
 * contains the same schema and preferred name as the given one. Returns -1 if
 * that schema could not be found.
 */
function getSchemaIndex(preferredName, schema, dataDefs) {
    /**
     * TODO: instead of iterating through the whole list every time, create a
     * hashing function and store all of the DataDefinitions in a hashmap.
     */
    for (let index = 0; index < dataDefs.length; index++) {
        const def = dataDefs[index];
        /**
         * TODO: deepEquals is not sufficient. We also need to resolve references.
         * However, deepEquals should work for vast majority of cases.
         */
        if (preferredName === def.preferredName && deepEqual(schema, def.schema)) {
            return index;
        }
    }
    // The schema could not be found in the master list
    return -1;
}
/**
 * Determines the preferred name to use for schema regardless of name collisions.
 *
 * In other words, determines the ideal name for a schema.
 *
 * Similar to getSchemaName() except it does not check if the name has already
 * been taken.
 */
function getPreferredName(names) {
    if (typeof names.preferred === 'string') {
        return sanitize(names.preferred, CaseStyle.PascalCase); // CASE: preferred name already known
    }
    else if (typeof names.fromRef === 'string') {
        return sanitize(names.fromRef, CaseStyle.PascalCase); // CASE: name from reference
    }
    else if (typeof names.fromSchema === 'string') {
        return sanitize(names.fromSchema, CaseStyle.PascalCase); // CASE: name from schema (i.e., "title" property in schema)
    }
    else if (typeof names.fromPath === 'string') {
        return sanitize(names.fromPath, CaseStyle.PascalCase); // CASE: name from path
    }
    else {
        return 'PlaceholderName'; // CASE: placeholder name
    }
}
/**
 * Determines name to use for schema from previously determined schemaNames and
 * considering not reusing existing names.
 */
function getSchemaName(names, usedNames) {
    if (Object.keys(names).length === 1 && typeof names.preferred === 'string') {
        throw new Error(`Cannot create data definition without name(s), excluding the ` +
            `preferred name.`);
    }
    let schemaName;
    if (typeof names.fromExtension === 'string') {
        const extensionTypeName = names.fromExtension;
        if (!isSanitized(extensionTypeName)) {
            throw new Error(`Cannot create type with name "${extensionTypeName}".\nYou ` +
                `provided "${extensionTypeName}" in ` +
                `${OAS_GRAPHQL_EXTENSIONS.TypeName}, but it is not ` +
                `GraphQL-safe."`);
        }
        if (usedNames.includes(extensionTypeName)) {
            throw new Error(`Cannot create type with name "${extensionTypeName}".\nYou provided ` +
                `"${names.fromExtension}" in ` +
                `${OAS_GRAPHQL_EXTENSIONS.TypeName}, but it conflicts ` +
                `with another type named "${extensionTypeName}".`);
        }
        if (!usedNames.includes(extensionTypeName)) {
            schemaName = names.fromExtension;
        }
    }
    // CASE: name from reference
    if (!schemaName && typeof names.fromRef === 'string') {
        const saneName = sanitize(names.fromRef, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromRef;
        }
    }
    // CASE: name from schema (i.e., "title" property in schema)
    if (!schemaName && typeof names.fromSchema === 'string') {
        const saneName = sanitize(names.fromSchema, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromSchema;
        }
    }
    // CASE: name from path
    if (!schemaName && typeof names.fromPath === 'string') {
        const saneName = sanitize(names.fromPath, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromPath;
        }
    }
    // CASE: all names are already used - create approximate name
    if (!schemaName) {
        schemaName = sanitize(typeof names.fromExtension === 'string'
            ? names.fromExtension
            : typeof names.fromRef === 'string'
                ? names.fromRef
                : typeof names.fromSchema === 'string'
                    ? names.fromSchema
                    : typeof names.fromPath === 'string'
                        ? names.fromPath
                        : 'PlaceholderName', CaseStyle.PascalCase);
    }
    if (usedNames.includes(schemaName)) {
        let appendix = 2;
        /**
         * GraphQL Objects cannot share the name so if the name already exists in
         * the master list append an incremental number until the name does not
         * exist anymore.
         */
        while (usedNames.includes(`${schemaName}${appendix}`)) {
            appendix++;
        }
        schemaName = `${schemaName}${appendix}`;
    }
    return schemaName;
}
/**
 * Sanitize the keys of a link object
 */
function sanitizeLinks({ links, data }) {
    const saneLinks = {};
    if (typeof links === 'object') {
        Object.keys(links).forEach((linkKey) => {
            const link = links[linkKey];
            const extensionFieldName = link[OAS_GRAPHQL_EXTENSIONS.FieldName];
            if (!isSanitized(extensionFieldName)) {
                throw new Error(`Cannot create link field with name ` +
                    `"${extensionFieldName}".\nYou provided "${extensionFieldName}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it is not ` +
                    `GraphQL-safe."`);
            }
            if (extensionFieldName in saneLinks) {
                throw new Error(`Cannot create link field with name ` +
                    `"${extensionFieldName}".\nYou provided ` +
                    `"${extensionFieldName}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                    `conflicts with another field named "${extensionFieldName}".`);
            }
            const linkFieldName = sanitize(extensionFieldName || linkKey, !data.options.simpleNames
                ? CaseStyle.camelCase
                : CaseStyle.simple);
            saneLinks[linkFieldName] = link;
        });
    }
    return saneLinks;
}
/**
 * Given an existing data definition, collapse the link object with the existing
 * one captured in the data definition.
 */
function collapseLinksIntoDataDefinition({ additionalLinks, existingDataDef, data }) {
    /**
     * Collapse links if possible, i.e. if the current operation has links,
     * combine them with the prexisting ones
     */
    if (typeof existingDataDef.links === 'object') {
        // Check if there are any overlapping links
        Object.keys(existingDataDef.links).forEach((saneLinkKey) => {
            if (!deepEqual(existingDataDef.links[saneLinkKey], additionalLinks[saneLinkKey])) {
                handleWarning({
                    mitigationType: MitigationTypes.DUPLICATE_LINK_KEY,
                    message: `Multiple operations with the same response body share the same sanitized ` +
                        `link key '${saneLinkKey}' but have different link definitions ` +
                        `'${JSON.stringify(existingDataDef.links[saneLinkKey])}' and ` +
                        `'${JSON.stringify(additionalLinks[saneLinkKey])}'.`,
                    data,
                    log: preprocessingLog$1
                });
                return;
            }
        });
        /**
         * Collapse the links
         *
         * Avoid overwriting preexisting links
         */
        existingDataDef.links = { ...additionalLinks, ...existingDataDef.links };
    }
    else {
        // No preexisting links, so simply assign the links
        existingDataDef.links = additionalLinks;
    }
}
/**
 * Recursively add all of the properties of an object to the data definition
 */
function addObjectPropertiesToDataDef(def, schema, required, isInputObjectType, data, oas) {
    /**
     * Resolve all required properties
     *
     * TODO: required may contain duplicates, which is not necessarily a problem
     */
    if (Array.isArray(schema.required)) {
        schema.required.forEach((requiredProperty) => {
            required.push(requiredProperty);
        });
    }
    for (let propertyKey in schema.properties) {
        if (!(propertyKey in def.subDefinitions)) {
            let propSchemaName = propertyKey;
            const propSchemaOrRef = schema.properties[propertyKey];
            let propSchema;
            if ('$ref' in propSchemaOrRef &&
                typeof propSchemaOrRef.$ref === 'string') {
                propSchemaName = propSchemaOrRef.$ref.split('/').pop();
                propSchema = resolveRef(propSchemaOrRef.$ref, oas);
            }
            else {
                propSchema = propSchemaOrRef;
            }
            const extensionTypeName = propSchema[OAS_GRAPHQL_EXTENSIONS.TypeName];
            const subDefinition = createDataDef({
                fromExtension: extensionTypeName,
                fromRef: propSchemaName,
                fromSchema: propSchema.title // TODO: Redundant because of fromRef but arguably, propertyKey is a better field name and title is a better type name
            }, propSchema, isInputObjectType, data, oas);
            // Add field type references
            def.subDefinitions[propertyKey] = subDefinition;
        }
        else {
            handleWarning({
                mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                message: `By way of resolving 'allOf', multiple schemas contain ` +
                    `properties with the same name, preventing consolidation. Cannot ` +
                    `add property '${propertyKey}' from schema '${JSON.stringify(schema)}' ` +
                    `to dataDefinition '${JSON.stringify(def)}'`,
                data,
                log: preprocessingLog$1
            });
        }
    }
}
function createAnyOfObject(saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas) {
    /**
     * Used to find incompatible properties
     *
     * Store a properties from the base and member schemas. Start with the base
     * schema properties.
     *
     * If there are multiple properties with the same name, it only needs to store
     * the contents of one of them.
     *
     * If it is conflicting, add to incompatiable
     * properties; if not, do nothing.
     */
    const allProperties = {};
    if ('properties' in collapsedSchema) {
        Object.entries(collapsedSchema.properties).forEach(([propertyName, propertyObjectOrRef]) => {
            let property;
            if ('$ref' in propertyObjectOrRef &&
                typeof propertyObjectOrRef.$ref === 'string') {
                property = resolveRef(propertyObjectOrRef.$ref, oas);
            }
            else {
                property = propertyObjectOrRef;
            }
            allProperties[propertyName] = property;
        });
    }
    // Store the names of properties with conflicting contents
    const incompatibleProperties = new Set();
    // An array containing the properties of all member schemas
    const memberProperties = [];
    collapsedSchema.anyOf.forEach((memberSchemaOrRef) => {
        // Collapsed schema should already be recursively resolved
        let memberSchema;
        if ('$ref' in memberSchemaOrRef &&
            typeof memberSchemaOrRef.$ref === 'string') {
            memberSchema = resolveRef(memberSchemaOrRef.$ref, oas);
        }
        else {
            memberSchema = memberSchemaOrRef;
        }
        if (memberSchema.properties) {
            const properties = {};
            Object.entries(memberSchema.properties).forEach(([propertyName, propertyObjectOrRef]) => {
                let property;
                if ('$ref' in propertyObjectOrRef &&
                    typeof propertyObjectOrRef.$ref === 'string') {
                    property = resolveRef(propertyObjectOrRef.$ref, oas);
                }
                else {
                    property = propertyObjectOrRef;
                }
                properties[propertyName] = property;
            });
            memberProperties.push(properties);
        }
    });
    /**
     * TODO: Check for consistent properties across all member schemas and
     * make them into non-nullable properties by manipulating the
     * required field
     */
    /**
     * Add properties from the member schemas (from anyOf) as well as check
     * for incompatible properties (conflicting properties between member
     * schemas and other member schemas or the base schema)
     */
    memberProperties.forEach((properties) => {
        Object.keys(properties).forEach((propertyName) => {
            if (!incompatibleProperties.has(propertyName) && // Has not been already identified as a problematic property
                typeof allProperties[propertyName] === 'object' &&
                !deepEqual(properties[propertyName], allProperties[propertyName])) {
                incompatibleProperties.add(propertyName);
            }
            /**
             * Save property to check in future iterations
             *
             * Can overwrite. If there is an incompatible property, we are
             * guaranteed to record it in incompatibleProperties
             */
            allProperties[propertyName] = properties[propertyName];
        });
    });
    def.subDefinitions = {};
    if (typeof collapsedSchema.properties === 'object' &&
        Object.keys(collapsedSchema.properties).length > 0) {
        /**
         * TODO: Instead of creating the entire dataDefinition, disregard
         * incompatible properties.
         */
        addObjectPropertiesToDataDef(def, collapsedSchema, def.required, isInputObjectType, data, oas);
    }
    memberProperties.forEach((properties) => {
        Object.keys(properties).forEach((propertyName) => {
            if (!incompatibleProperties.has(propertyName)) {
                // Dereferenced by processing anyOfData
                const propertySchema = properties[propertyName];
                const extensionTypeName = propertySchema[OAS_GRAPHQL_EXTENSIONS.TypeName];
                const subDefinition = createDataDef({
                    fromExtension: extensionTypeName,
                    fromRef: propertyName,
                    fromSchema: propertySchema.title // TODO: Currently not utilized because of fromRef but arguably, propertyKey is a better field name and title is a better type name
                }, propertySchema, isInputObjectType, data, oas);
                /**
                 * Add field type references
                 * There should not be any collisions
                 */
                def.subDefinitions[propertyName] = subDefinition;
            }
        });
    });
    // Add in incompatible properties
    incompatibleProperties.forEach((propertyName) => {
        // TODO: add description
        def.subDefinitions[propertyName] = {
            targetGraphQLType: TargetGraphQLType.json
        };
    });
    data.usedTypeNames.push(saneName);
    data.usedTypeNames.push(saneInputName);
    data.defs.push(def);
    def.targetGraphQLType = TargetGraphQLType.object;
    return def;
}
function createOneOfUnion(saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas) {
    if (isInputObjectType) {
        handleWarning({
            mitigationType: MitigationTypes.INPUT_UNION,
            message: `Input object types cannot be composed of union types.`,
            data,
            log: preprocessingLog$1
        });
        def.targetGraphQLType = TargetGraphQLType.json;
        return def;
    }
    def.subDefinitions = [];
    collapsedSchema.oneOf.forEach((memberSchemaOrRef) => {
        // Collapsed schema should already be recursively resolved
        let fromRef;
        let memberSchema;
        if ('$ref' in memberSchemaOrRef &&
            typeof memberSchemaOrRef.$ref === 'string') {
            fromRef = memberSchemaOrRef.$ref.split('/').pop();
            memberSchema = resolveRef(memberSchemaOrRef.$ref, oas);
        }
        else {
            memberSchema = memberSchemaOrRef;
        }
        const extensionTypeName = memberSchema[OAS_GRAPHQL_EXTENSIONS.TypeName];
        const subDefinition = createDataDef({
            fromExtension: extensionTypeName,
            fromRef,
            fromSchema: memberSchema.title,
            fromPath: `${saneName}Member`
        }, memberSchema, isInputObjectType, data, oas, def.links);
        def.subDefinitions.push(subDefinition);
    });
    // Not all member schemas may have been turned into GraphQL member types
    if (def.subDefinitions.length > 0 &&
        def.subDefinitions.every((subDefinition) => {
            return subDefinition.targetGraphQLType === TargetGraphQLType.object;
        })) {
        // Ensure all member schemas have been verified as object types
        data.usedTypeNames.push(saneName);
        data.usedTypeNames.push(saneInputName);
        data.defs.push(def);
        def.targetGraphQLType = TargetGraphQLType.oneOfUnion;
        return def;
    }
    else {
        handleWarning({
            mitigationType: MitigationTypes.COMBINE_SCHEMAS,
            message: `Schema '${JSON.stringify(def.schema)}' contains 'oneOf' so ` +
                `create a GraphQL union type but all member schemas are not` +
                `object types and union member types must be object types.`,
            mitigationAddendum: `Use arbitrary JSON type instead.`,
            data,
            log: preprocessingLog$1
        });
        def.targetGraphQLType = TargetGraphQLType.json;
        return def;
    }
}

// Copyright IBM Corp. 2018. All Rights Reserved.
/**
 * We need to slightly modify the GraphQLJSON type.
 *
 * We need to remove the _openAPIToGraphQL or else we will leak data about
 * the API requests. Therefore, we need to change the serialize() function
 * in the GraphQLJSON type.
 */
const CleanGraphQLJSON = new GraphQLScalarType({
    ...GraphQLJSON.toConfig(),
    serialize: (value) => {
        let cleanValue;
        /**
         * If the value is an object and contains the _openAPIToGraphQL,
         * make a copy of the object without said field.
         *
         * NOTE: The value will only contain the _openAPIToGraphQL field if
         * an OAS operation is determined to return an arbitrary JSON type.
         * Not if a property of the return type contains an arbitrary JSON
         * type.
         */
        if (value &&
            typeof value === 'object' &&
            typeof value[OPENAPI_TO_GRAPHQL] === 'object') {
            cleanValue = { ...value };
            delete cleanValue[OPENAPI_TO_GRAPHQL];
            /**
             * As a GraphQLJSON type, the value can also be a scalar or array or
             * an object without the _openAPIToGraphQL field. In that case,
             * just use the original value.
             */
        }
        else {
            cleanValue = value;
        }
        // Use original serialize() function but with clean value
        return GraphQLJSON.serialize(cleanValue);
    }
});
const translationLog$2 = debug('translation');
/**
 * Creates and returns a GraphQL type for the given JSON schema.
 */
function getGraphQLType({ def, operation, data, iteration = 0, isInputObjectType = false, fetch }) {
    const name = isInputObjectType
        ? def.graphQLInputObjectTypeName
        : def.graphQLTypeName;
    // Avoid excessive iterations
    if (iteration === 50) {
        throw new Error(`GraphQL type ${name} has excessive nesting of other types`);
    }
    switch (def.targetGraphQLType) {
        // CASE: object - create object type
        case TargetGraphQLType.object:
        case TargetGraphQLType.anyOfObject:
            return createOrReuseOt({
                def,
                operation,
                data,
                iteration,
                isInputObjectType,
                fetch
            });
        // CASE: union - create union type
        case TargetGraphQLType.oneOfUnion:
            return createOrReuseUnion({
                def,
                operation,
                data,
                iteration,
                fetch
            });
        // CASE: list - create list type
        case TargetGraphQLType.list:
            return createOrReuseList({
                def,
                operation,
                data,
                iteration,
                isInputObjectType,
                fetch
            });
        // CASE: enum - create enum type
        case TargetGraphQLType.enum:
            return createOrReuseEnum({
                def,
                data
            });
        // CASE: scalar - return scalar type
        case TargetGraphQLType.string:
            def.graphQLType = GraphQLString;
            return def.graphQLType;
        case TargetGraphQLType.integer:
            def.graphQLType = GraphQLInt;
            return def.graphQLType;
        case TargetGraphQLType.float:
            def.graphQLType = GraphQLFloat;
            return def.graphQLType;
        case TargetGraphQLType.boolean:
            def.graphQLType = GraphQLBoolean;
            return def.graphQLType;
        case TargetGraphQLType.id:
            def.graphQLType = GraphQLID;
            return def.graphQLType;
        case TargetGraphQLType.json:
            def.graphQLType = CleanGraphQLJSON;
            return def.graphQLType;
        case TargetGraphQLType.bigint:
            def.graphQLType = GraphQLBigInt;
            return def.graphQLType;
        case TargetGraphQLType.upload:
            def.graphQLType = GraphQLUpload;
            return def.graphQLType;
    }
}
/**
 * Creates an (input) object type or return an existing one, and stores it
 * in data
 *
 * A returned GraphQLObjectType has the following internal structure:
 *
 *   new GraphQLObjectType({
 *     name        // Optional name of the type
 *     description // Optional description of type
 *     fields      // REQUIRED returning fields
 *       type      // REQUIRED definition of the field type
 *       args      // Optional definition of types
 *       resolve   // Optional function defining how to obtain this type
 *   })
 */
function createOrReuseOt({ def, operation, data, iteration, isInputObjectType, fetch }) {
    // Try to reuse a preexisting (input) object type
    // CASE: query - reuse object type
    if (!isInputObjectType) {
        if (def.graphQLType && typeof def.graphQLType !== 'undefined') {
            translationLog$2(`Reuse object type '${def.graphQLTypeName}'` +
                (typeof operation === 'object'
                    ? ` (for operation '${operation.operationString}')`
                    : ''));
            return def.graphQLType;
        }
        // CASE: mutation - reuse input object type
    }
    else {
        if (def.graphQLInputObjectType &&
            typeof def.graphQLInputObjectType !== 'undefined') {
            translationLog$2(`Reuse input object type '${def.graphQLInputObjectTypeName}'` +
                (typeof operation === 'object'
                    ? ` (for operation '${operation.operationString}')`
                    : ''));
            return def.graphQLInputObjectType;
        }
    }
    // Cannot reuse preexisting (input) object type, therefore create one
    const schema = def.schema;
    const description = schema.description;
    // CASE: query - create object type
    if (!isInputObjectType) {
        translationLog$2(`Create object type '${def.graphQLTypeName}'` +
            (typeof operation === 'object'
                ? ` (for operation '${operation.operationString}')`
                : ''));
        def.graphQLType = new GraphQLObjectType({
            name: def.graphQLTypeName,
            description,
            fields: () => {
                return createFields({
                    def,
                    links: def.links,
                    operation,
                    data,
                    iteration,
                    isInputObjectType: false,
                    fetch
                });
            }
        });
        return def.graphQLType;
        // CASE: mutation - create input object type
    }
    else {
        translationLog$2(`Create input object type '${def.graphQLInputObjectTypeName}'` +
            (typeof operation === 'object'
                ? ` (for operation '${operation.operationString}')`
                : ''));
        def.graphQLInputObjectType = new GraphQLInputObjectType({
            name: def.graphQLInputObjectTypeName,
            description,
            fields: () => {
                return createFields({
                    def,
                    links: {},
                    operation,
                    data,
                    iteration,
                    isInputObjectType: true,
                    fetch
                });
            }
        });
        return def.graphQLInputObjectType;
    }
}
/**
 * Creates a union type or return an existing one, and stores it in data
 */
function createOrReuseUnion({ def, operation, data, iteration, fetch }) {
    // Try to reuse existing union type
    if (typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse union type '${def.graphQLTypeName}'` +
            (typeof operation === 'object'
                ? ` (for operation '${operation.operationString}')`
                : ''));
        return def.graphQLType;
    }
    else {
        translationLog$2(`Create union type '${def.graphQLTypeName}'` +
            (typeof operation === 'object'
                ? ` (for operation '${operation.operationString}')`
                : ''));
        const schema = def.schema;
        const description = typeof schema.description !== 'undefined'
            ? schema.description
            : 'No description available.';
        const memberTypeDefinitions = def.subDefinitions;
        const types = Object.values(memberTypeDefinitions).map((memberTypeDefinition) => {
            return getGraphQLType({
                def: memberTypeDefinition,
                operation,
                data,
                iteration: iteration + 1,
                isInputObjectType: false,
                fetch
            });
        });
        /**
         * Check for ambiguous member types
         *
         * i.e. member types that can be confused with each other.
         */
        checkAmbiguousMemberTypes(def, types, data);
        def.graphQLType = new GraphQLUnionType({
            name: def.graphQLTypeName,
            description,
            types,
            resolveType: (source, context, info) => {
                var _a;
                const properties = Object.keys(source)
                    // Remove custom _openAPIToGraphQL property used to pass data
                    .filter((property) => property !== '_openAPIToGraphQL');
                /**
                 * Find appropriate member type
                 *
                 * TODO: currently, the check is performed by only checking the property
                 * names. In the future, we should also check the types of those
                 * properties.
                 *
                 * TODO: there is a chance a that an intended member type cannot be
                 * identified if, for whatever reason, the return data is a superset
                 * of the fields specified in the OAS
                 */
                return (_a = types.find((type) => {
                    const typeFields = Object.keys(type.getFields());
                    // The type should be a superset of the properties
                    if (properties.length <= typeFields.length) {
                        return properties.every((property) => typeFields.includes(property));
                    }
                    return false;
                })) === null || _a === void 0 ? void 0 : _a.name;
            }
        });
        return def.graphQLType;
    }
}
/**
 * Check for ambiguous member types
 *
 * i.e. member types that can be confused with each other.
 */
function checkAmbiguousMemberTypes(def, types, data) {
    types.sort((a, b) => {
        const aFieldLength = Object.keys(a.getFields()).length;
        const bFieldLength = Object.keys(b.getFields()).length;
        if (aFieldLength < bFieldLength) {
            return -1;
        }
        else if (aFieldLength < bFieldLength) {
            return 1;
        }
        else {
            return 0;
        }
    });
    for (let i = 0; i < types.length - 1; i++) {
        const currentType = types[i];
        for (let j = i + 1; j < types.length; j++) {
            const otherType = types[j];
            // TODO: Check the value, not just the field name
            if (Object.keys(currentType.getFields()).every((field) => {
                return Object.keys(otherType.getFields()).includes(field);
            })) {
                handleWarning({
                    mitigationType: MitigationTypes.AMBIGUOUS_UNION_MEMBERS,
                    message: `Union created from schema '${JSON.stringify(def)}' contains ` +
                        `member types such as '${currentType}' and '${otherType}' ` +
                        `which are ambiguous. Ambiguous member types can cause ` +
                        `problems when trying to resolve types.`,
                    data,
                    log: translationLog$2
                });
                return;
            }
        }
    }
}
/**
 * Creates a list type or returns an existing one, and stores it in data
 */
function createOrReuseList({ def, operation, iteration, isInputObjectType, data, fetch }) {
    const name = isInputObjectType
        ? def.graphQLInputObjectTypeName
        : def.graphQLTypeName;
    // Try to reuse existing Object Type
    if (!isInputObjectType &&
        def.graphQLType &&
        typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse GraphQLList '${def.graphQLTypeName}'`);
        return def.graphQLType;
    }
    else if (isInputObjectType &&
        def.graphQLInputObjectType &&
        typeof def.graphQLInputObjectType !== 'undefined') {
        translationLog$2(`Reuse GraphQLList '${def.graphQLInputObjectTypeName}'`);
        return def.graphQLInputObjectType;
    }
    // Create new List Object Type
    translationLog$2(`Create GraphQLList '${def.graphQLTypeName}'`);
    // Get definition of the list item, which should be in the sub definitions
    const itemDef = def.subDefinitions;
    // Equivalent to schema.items
    const itemsSchema = itemDef.schema;
    // Equivalent to `{name}ListItem`
    const itemsName = itemDef.graphQLTypeName;
    const itemsType = getGraphQLType({
        def: itemDef,
        data,
        operation,
        iteration: iteration + 1,
        isInputObjectType,
        fetch
    });
    if (itemsType !== null) {
        const listObjectType = new GraphQLList(itemsType);
        // Store newly created list type
        if (!isInputObjectType) {
            def.graphQLType = listObjectType;
        }
        else {
            def.graphQLInputObjectType = listObjectType;
        }
        return listObjectType;
    }
    else {
        throw new Error(`Cannot create list item object type '${itemsName}' in list ` +
            `'${name}' with schema '${JSON.stringify(itemsSchema)}'.`);
    }
}
/**
 * Creates an enum type or returns an existing one, and stores it in data
 */
function createOrReuseEnum({ def, data }) {
    /**
     * Try to reuse existing enum type
     *
     * Enum types do not have an input variant so only check def.ot
     */
    if (def.graphQLType && typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse GraphQLEnumType '${def.graphQLTypeName}'`);
        return def.graphQLType;
    }
    else {
        translationLog$2(`Create GraphQLEnumType '${def.graphQLTypeName}'`);
        const values = {};
        const extensionEnumMapping = def.schema[OAS_GRAPHQL_EXTENSIONS.EnumMapping] || {};
        def.schema.enum.forEach((enumValue) => {
            const enumValueString = enumValue.toString();
            const extensionEnumValue = extensionEnumMapping[enumValueString];
            if (!isSanitized(extensionEnumValue)) {
                throw new Error(`Cannot create enum value "${extensionEnumValue}".\nYou ` +
                    `provided "${extensionEnumValue}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.EnumMapping}, but it is not ` +
                    `GraphQL-safe."`);
            }
            const emumValue = extensionEnumValue ||
                sanitize(enumValueString, !data.options.simpleEnumValues
                    ? CaseStyle.ALL_CAPS
                    : CaseStyle.simple);
            if (extensionEnumValue in values) {
                throw new Error(`Cannot create enum value "${extensionEnumValue}".\nYou ` +
                    `provided "${extensionEnumValue}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.EnumMapping}, but it ` +
                    `conflicts with another value "${extensionEnumValue}".`);
            }
            values[emumValue] = { value: enumValue };
        });
        // Store newly created Enum Object Type
        def.graphQLType = new GraphQLEnumType({
            name: def.graphQLTypeName,
            values
        });
        return def.graphQLType;
    }
}
/**
 * Creates the fields object to be used by an (input) object type
 */
function createFields({ def, links, operation, data, iteration, isInputObjectType, fetch }) {
    let fields = {};
    const fieldTypeDefinitions = def.subDefinitions;
    // Create fields for properties
    for (let fieldName in fieldTypeDefinitions) {
        const fieldTypeDefinition = fieldTypeDefinitions[fieldName];
        const fieldSchema = fieldTypeDefinition.schema;
        // Get object type describing the property
        const objectType = getGraphQLType({
            def: fieldTypeDefinition,
            operation,
            data,
            iteration: iteration + 1,
            isInputObjectType,
            fetch
        });
        const requiredProperty = typeof def.required === 'object' && def.required.includes(fieldName);
        // Finally, add the object type to the fields (using sanitized field name)
        if (objectType) {
            const extensionFieldName = fieldSchema === null || fieldSchema === void 0 ? void 0 : fieldSchema[OAS_GRAPHQL_EXTENSIONS.FieldName];
            if (!isSanitized(extensionFieldName)) {
                throw new Error(`Cannot create field with name "${extensionFieldName}".\nYou ` +
                    `provided "${extensionFieldName}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it is not ` +
                    `GraphQL-safe."`);
            }
            if (extensionFieldName && extensionFieldName in fields) {
                throw new Error(`Cannot create field with name "${extensionFieldName}".\nYou ` +
                    `provided "${extensionFieldName}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                    `conflicts with another field named "${extensionFieldName}".`);
            }
            const saneFieldName = extensionFieldName ||
                sanitize(fieldName, !data.options.simpleNames
                    ? CaseStyle.camelCase
                    : CaseStyle.simple);
            const sanePropName = storeSaneName(saneFieldName, fieldName, data.saneMap);
            fields[sanePropName] = {
                type: requiredProperty
                    ? new GraphQLNonNull(objectType)
                    : objectType,
                description: typeof fieldSchema === 'object' ? fieldSchema.description : null
            };
        }
        else {
            handleWarning({
                mitigationType: MitigationTypes.CANNOT_GET_FIELD_TYPE,
                message: `Cannot obtain GraphQL type for field '${fieldName}' in ` +
                    `GraphQL type '${JSON.stringify(def.schema)}'.`,
                data,
                log: translationLog$2
            });
        }
    }
    if (typeof links === 'object' && // Links are present
        !isInputObjectType // Only object type (input object types cannot make use of links)
    ) {
        for (let saneLinkKey in links) {
            translationLog$2(`Create link '${saneLinkKey}'...`);
            // Check if key is already in fields
            if (saneLinkKey in fields) {
                handleWarning({
                    mitigationType: MitigationTypes.LINK_NAME_COLLISION,
                    message: `Cannot create link '${saneLinkKey}' because parent ` +
                        `object type already contains a field with the same ` +
                        `(sanitized) name.`,
                    data,
                    log: translationLog$2
                });
            }
            else {
                const link = links[saneLinkKey];
                // Get linked operation
                let linkedOpId;
                // TODO: href is yet another alternative to operationRef and operationId
                if (typeof link.operationId === 'string') {
                    linkedOpId = link.operationId;
                }
                else if (typeof link.operationRef === 'string') {
                    linkedOpId = linkOpRefToOpId({
                        links,
                        linkKey: saneLinkKey,
                        operation,
                        data
                    });
                }
                /**
                 * linkedOpId may not be initialized because operationRef may lead to an
                 * operation object that does not have an operationId
                 */
                if (typeof linkedOpId === 'string' && linkedOpId in data.operations) {
                    const linkedOp = data.operations[linkedOpId];
                    // Determine parameters provided via link
                    let argsFromLink = link.parameters;
                    // Get arguments that are not provided by the linked operation
                    let dynamicParams = linkedOp.parameters;
                    if (typeof argsFromLink === 'object') {
                        dynamicParams = dynamicParams.filter((param) => {
                            return typeof argsFromLink[param.name] === 'undefined';
                        });
                    }
                    // Get resolve function for link
                    const linkResolver = getResolver({
                        operation: linkedOp,
                        argsFromLink: argsFromLink,
                        data,
                        baseUrl: data.options.baseUrl,
                        requestOptions: data.options.requestOptions,
                        fileUploadOptions: data.options.fileUploadOptions,
                        fetch
                    });
                    // Get arguments for link
                    const args = getArgs({
                        parameters: dynamicParams,
                        operation: linkedOp,
                        data,
                        fetch
                    });
                    // Get response object type
                    const resObjectType = linkedOp.responseDefinition.graphQLType !== undefined
                        ? linkedOp.responseDefinition.graphQLType
                        : getGraphQLType({
                            def: linkedOp.responseDefinition,
                            operation,
                            data,
                            iteration: iteration + 1,
                            isInputObjectType: false,
                            fetch
                        });
                    let description = link.description;
                    if (data.options.equivalentToMessages) {
                        if (typeof description !== 'string') {
                            description = `Equivalent to ${linkedOp.operationString}`;
                        }
                        else {
                            description += `\n\nEquivalent to ${linkedOp.operationString}`;
                        }
                    }
                    // Finally, add the object type to the fields (using sanitized field name)
                    // TODO: check if fields already has this field name
                    fields[saneLinkKey] = {
                        type: resObjectType,
                        resolve: linkResolver,
                        args,
                        description
                    };
                }
                else {
                    handleWarning({
                        mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                        message: `Cannot resolve target of link '${saneLinkKey}'`,
                        data,
                        log: translationLog$2
                    });
                }
            }
        }
    }
    fields = sortObject(fields);
    return fields;
}
/**
 * Returns the operationId that an operationRef is associated to
 *
 * NOTE: If the operation does not natively have operationId, this function
 * will try to produce an operationId the same way preprocessor.js does it.
 *
 * Any changes to constructing operationIds in preprocessor.js should be
 * reflected here.
 */
function linkOpRefToOpId({ links, linkKey, operation, data }) {
    const link = links[linkKey];
    if (typeof link.operationRef === 'string') {
        // TODO: external refs
        const operationRef = link.operationRef;
        let linkLocation;
        let linkRelativePathAndMethod;
        /**
         * Example relative path: '#/paths/~12.0~1repositories~1{username}/get'
         * Example absolute path: 'https://na2.gigantic-server.com/#/paths/~12.0~1repositories~1{username}/get'
         * Extract relative path from relative path
         */
        if (operationRef.substring(0, 8) === '#/paths/') {
            linkRelativePathAndMethod = operationRef;
            // Extract relative path from absolute path
        }
        else {
            /**
             * '#' may exist in other places in the path
             * '/#/' is more likely to point to the beginning of the path
             */
            const firstPathIndex = operationRef.indexOf('#/paths/');
            // Found a relative path candidate
            if (firstPathIndex !== -1) {
                // Check to see if there are other relative path candidates
                const lastPathIndex = operationRef.lastIndexOf('#/paths/');
                if (firstPathIndex !== lastPathIndex) {
                    handleWarning({
                        mitigationType: MitigationTypes.AMBIGUOUS_LINK,
                        message: `The link '${linkKey}' in operation '${operation.operationString}' ` +
                            `contains an ambiguous operationRef '${operationRef}', ` +
                            `meaning it has multiple instances of the string '#/paths/'`,
                        data,
                        log: translationLog$2
                    });
                    return;
                }
                linkLocation = operationRef.substring(0, firstPathIndex);
                linkRelativePathAndMethod = operationRef.substring(firstPathIndex);
                // Cannot find relative path candidate
            }
            else {
                handleWarning({
                    mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                    message: `The link '${linkKey}' in operation '${operation.operationString}' ` +
                        `does not contain a valid path in operationRef '${operationRef}', ` +
                        `meaning it does not contain a string '#/paths/'`,
                    data,
                    log: translationLog$2
                });
                return;
            }
        }
        // Infer operationId from relative path
        if (typeof linkRelativePathAndMethod === 'string') {
            let linkPath;
            let linkMethod;
            /**
             * NOTE: I wish we could extract the linkedOpId by matching the
             * linkedOpObject with an operation in data and extracting the operationId
             * there but that does not seem to be possible especiially because you
             * need to know the operationId just to access the operations so what I
             * have to do is reconstruct the operationId the same way preprocessing
             * does it
             */
            /**
             * linkPath should be the path followed by the method
             *
             * Find the slash that divides the path from the method
             */
            const pivotSlashIndex = linkRelativePathAndMethod.lastIndexOf('/');
            // Check if there are any '/' in the linkPath
            if (pivotSlashIndex !== -1) {
                // Get method
                // Check if there is a method at the end of the linkPath
                if (pivotSlashIndex !== linkRelativePathAndMethod.length - 1) {
                    try {
                        // Start at +1 because we do not want the starting '/'
                        linkMethod = methodToHttpMethod(linkRelativePathAndMethod.substring(pivotSlashIndex + 1));
                    }
                    catch (_a) {
                        handleWarning({
                            mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                            message: `The operationRef '${operationRef}' contains an ` +
                                `invalid HTTP method '${linkMethod}'`,
                            data,
                            log: translationLog$2
                        });
                        return;
                    }
                    // There is no method at the end of the path
                }
                else {
                    handleWarning({
                        mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                        message: `The operationRef '${operationRef}' does not contain an` +
                            `HTTP method`,
                        data,
                        log: translationLog$2
                    });
                    return;
                }
                /**
                 * Get path
                 *
                 * Substring starts at index 8 and ends at pivotSlashIndex to exclude
                 * the '/'s at the ends of the path
                 *
                 * TODO: improve removing '/#/paths'?
                 */
                linkPath = linkRelativePathAndMethod.substring(8, pivotSlashIndex);
                /**
                 * linkPath is currently a JSON Pointer
                 *
                 * Revert the escaped '/', represented by '~1', to form intended path
                 */
                linkPath = linkPath.replace(/~1/g, '/');
                // Find the right oas
                const oas = typeof linkLocation === 'undefined'
                    ? operation.oas
                    : getOasFromLinkLocation(linkLocation, link, data);
                // If the link was external, make sure that an OAS could be identified
                if (typeof oas !== 'undefined') {
                    if (typeof linkMethod === 'string' && typeof linkPath === 'string') {
                        let linkedOpId;
                        if (linkPath in oas.paths && linkMethod in oas.paths[linkPath]) {
                            const linkedOpObject = oas.paths[linkPath][linkMethod];
                            if ('operationId' in linkedOpObject) {
                                linkedOpId = linkedOpObject.operationId;
                            }
                        }
                        if (typeof linkedOpId !== 'string') {
                            linkedOpId = generateOperationId(linkMethod, linkPath);
                        }
                        if (linkedOpId in data.operations) {
                            return linkedOpId;
                        }
                        else {
                            handleWarning({
                                mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                                message: `The link '${linkKey}' references an operation with ` +
                                    `operationId '${linkedOpId}' but no such operation exists. ` +
                                    `Note that the operationId may be autogenerated but ` +
                                    `regardless, the link could not be matched to an operation.`,
                                data,
                                log: translationLog$2
                            });
                            return;
                        }
                        // Path and method could not be found
                    }
                    else {
                        handleWarning({
                            mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                            message: `Cannot identify path and/or method, '${linkPath} and ` +
                                `'${linkMethod}' respectively, from operationRef ` +
                                `'${operationRef}' in link '${linkKey}'`,
                            data,
                            log: translationLog$2
                        });
                        return;
                    }
                    // External link could not be resolved
                }
                else {
                    handleWarning({
                        mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                        message: `The link '${link.operationRef}' references an external OAS ` +
                            `but it was not provided`,
                        data,
                        log: translationLog$2
                    });
                    return;
                }
                // Cannot split relative path into path and method sections
            }
            else {
                handleWarning({
                    mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                    message: `Cannot extract path and/or method from operationRef ` +
                        `'${operationRef}' in link '${linkKey}'`,
                    data,
                    log: translationLog$2
                });
                return;
            }
            // Cannot extract relative path from absolute path
        }
        else {
            handleWarning({
                mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                message: `Cannot extract path and/or method from operationRef ` +
                    `'${operationRef}' in link '${linkKey}'`,
                data,
                log: translationLog$2
            });
            return;
        }
    }
}
/**
 * Determin if an argument should be created if the argument has already been
 * provided through the options
 */
function skipArg(parameter, operation, data) {
    if (typeof data.options === 'object') {
        switch (parameter.in) {
            case 'header':
                // Check header option
                if (typeof data.options.headers === 'object' &&
                    parameter.name in data.options.headers) {
                    return true;
                }
                else if (typeof data.options.headers === 'function') {
                    const headers = data.options.headers(operation.method, operation.path, operation.oas.info.title);
                    if (typeof headers === 'object') {
                        return true;
                    }
                    // Check requestOptions option
                }
                else if (typeof data.options.requestOptions === 'object') {
                    if (typeof data.options.requestOptions.headers === 'object' &&
                        parameter.name in data.options.requestOptions.headers) {
                        return true;
                    }
                    else if (typeof data.options.requestOptions.headers === 'function') {
                        const headers = data.options.requestOptions.headers(operation.method, operation.path, operation.oas.info.title);
                        if (typeof headers === 'object') {
                            return true;
                        }
                    }
                }
                break;
            case 'query':
                // Check header option
                if (typeof data.options.qs === 'object' &&
                    parameter.name in data.options.qs) {
                    return true;
                    // Check requestOptions option
                }
                else if (typeof data.options.requestOptions === 'object' &&
                    typeof data.options.requestOptions.qs === 'object' &&
                    parameter.name in data.options.requestOptions.qs) {
                    return true;
                }
                break;
        }
    }
    return false;
}
/**
 * Creates the arguments for resolving a field
 *
 * Arguments that are provided via options will be ignored
 */
function getArgs({ requestPayloadDef, parameters, operation, data, fetch }) {
    let args = {};
    // Handle params:
    parameters.forEach((parameter) => {
        // We need at least a name
        if (typeof parameter.name !== 'string') {
            handleWarning({
                mitigationType: MitigationTypes.INVALID_OAS,
                message: `The operation '${operation.operationString}' contains a ` +
                    `parameter '${JSON.stringify(parameter)}' with no 'name' property`,
                data,
                log: translationLog$2
            });
            return;
        }
        // If this parameter is provided via options, ignore
        if (skipArg(parameter, operation, data)) {
            return;
        }
        /**
         * Determine type of parameter
         *
         * The type of the parameter can either be contained in the "schema" field
         * or the "content" field (but not both)
         */
        let schema;
        if (typeof parameter.schema === 'object') {
            schema = parameter.schema;
        }
        else if (typeof parameter.content === 'object') {
            if (typeof parameter.content['application/json'] === 'object' &&
                typeof parameter.content['application/json'].schema === 'object') {
                schema = parameter.content['application/json'].schema;
            }
            else {
                handleWarning({
                    mitigationType: MitigationTypes.NON_APPLICATION_JSON_SCHEMA,
                    message: `The operation '${operation.operationString}' contains a ` +
                        `parameter '${JSON.stringify(parameter)}' that has a 'content' ` +
                        `property but no schemas in application/json format. The ` +
                        `parameter will not be created`,
                    data,
                    log: translationLog$2
                });
                return;
            }
        }
        else {
            // Invalid OAS according to 3.0.2
            handleWarning({
                mitigationType: MitigationTypes.INVALID_OAS,
                message: `The operation '${operation.operationString}' contains a ` +
                    `parameter '${JSON.stringify(parameter)}' with no 'schema' or ` +
                    `'content' property`,
                data,
                log: translationLog$2
            });
            return;
        }
        /**
         * Resolving the reference is necessary later in the code and by doing it,
         * we can avoid doing it a second time in resolveRev()
         */
        if ('$ref' in schema) {
            schema = resolveRef(schema.$ref, operation.oas);
        }
        const paramDef = createDataDef({
            fromSchema: parameter.name,
            fromExtension: schema[OAS_GRAPHQL_EXTENSIONS.TypeName]
        }, schema, true, data, operation.oas);
        const type = getGraphQLType({
            def: paramDef,
            operation,
            data,
            iteration: 0,
            isInputObjectType: true,
            fetch
        });
        /**
         * Sanitize the argument name
         *
         * NOTE: when matching these parameters back to requests, we need to again
         * use the real parameter name
         */
        const saneName = sanitize(parameter.name, !data.options.simpleNames
            ? CaseStyle.camelCase
            : CaseStyle.simple);
        // Parameters are not required when a default exists:
        let hasDefault = false;
        if (typeof parameter.schema === 'object') {
            let schema = parameter.schema;
            if ('$ref' in schema) {
                schema = resolveRef(schema.$ref, operation.oas);
            }
            if (typeof schema.default !== 'undefined') {
                hasDefault = true;
            }
        }
        const paramRequired = parameter.required && !hasDefault;
        args[saneName] = {
            type: paramRequired ? new GraphQLNonNull(type) : type,
            description: parameter.description // Might be undefined
        };
    });
    // Add limit argument
    if (data.options.addLimitArgument &&
        typeof operation.responseDefinition === 'object' &&
        operation.responseDefinition.schema.type === 'array' &&
        // Only add limit argument to lists of object types, not to lists of scalar types
        (operation.responseDefinition.subDefinitions.schema
            .type === 'object' ||
            operation.responseDefinition.subDefinitions.schema
                .type === 'array')) {
        // Make sure slicing arguments will not overwrite preexisting arguments
        if ('limit' in args) {
            handleWarning({
                mitigationType: MitigationTypes.LIMIT_ARGUMENT_NAME_COLLISION,
                message: `The 'limit' argument cannot be added ` +
                    `because of a preexisting argument in ` +
                    `operation ${operation.operationString}`,
                data,
                log: translationLog$2
            });
        }
        else {
            args['limit'] = {
                type: GraphQLInt,
                description: `Auto-generated argument that limits the size of ` +
                    `returned list of objects/list, selecting the first \`n\` ` +
                    `elements of the list`
            };
        }
    }
    // Handle request payload (if present):
    if (typeof requestPayloadDef === 'object') {
        const reqObjectType = getGraphQLType({
            def: requestPayloadDef,
            data,
            operation,
            isInputObjectType: true,
            fetch
        });
        // Sanitize the argument name
        const saneName = data.options.genericPayloadArgName
            ? 'requestBody'
            : uncapitalize(requestPayloadDef.graphQLInputObjectTypeName); // Already sanitized
        const reqRequired = typeof operation === 'object' &&
            typeof operation.payloadRequired === 'boolean'
            ? operation.payloadRequired
            : false;
        args[saneName] = {
            type: reqRequired ? new GraphQLNonNull(reqObjectType) : reqObjectType,
            // TODO: addendum to the description explaining this is the request body
            description: requestPayloadDef.schema.description
        };
    }
    args = sortObject(args);
    return args;
}
/**
 * Used in the context of links, specifically those using an external operationRef
 * If the reference is an absolute reference, determine the type of location
 *
 * For example, name reference, file path, web-hosted OAS link, etc.
 */
function getLinkLocationType(linkLocation) {
    // TODO: currently we only support the title as a link location
    return 'title';
}
/**
 * Used in the context of links, specifically those using an external operationRef
 * Based on the location of the OAS, retrieve said OAS
 */
function getOasFromLinkLocation(linkLocation, link, data) {
    // May be an external reference
    switch (getLinkLocationType()) {
        case 'title':
            // Get the possible
            const possibleOass = data.oass.filter((oas) => {
                return oas.info.title === linkLocation;
            });
            // Check if there are an ambiguous OASs
            if (possibleOass.length === 1) {
                // No ambiguity
                return possibleOass[0];
            }
            else if (possibleOass.length > 1) {
                // Some ambiguity
                handleWarning({
                    mitigationType: MitigationTypes.AMBIGUOUS_LINK,
                    message: `The operationRef '${link.operationRef}' references an ` +
                        `OAS '${linkLocation}' but multiple OASs share the same title`,
                    data,
                    log: translationLog$2
                });
            }
            else {
                // No OAS had the expected title
                handleWarning({
                    mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                    message: `The operationRef '${link.operationRef}' references an ` +
                        `OAS '${linkLocation}' but no such OAS was provided`,
                    data,
                    log: translationLog$2
                });
            }
            break;
        // // TODO
        // case 'url':
        //   break
        // // TODO
        // case 'file':
        //   break
        // TODO: should title be default?
        // In cases of names like api.io
        default:
            handleWarning({
                mitigationType: MitigationTypes.UNRESOLVABLE_LINK,
                message: `The link location of the operationRef ` +
                    `'${link.operationRef}' is currently not supported\n` +
                    `Currently only the title of the OAS is supported`,
                data,
                log: translationLog$2
            });
    }
}

// Copyright IBM Corp. 2018. All Rights Reserved.
/**
 * Returns empty GraphQLObjectType.
 */
function getEmptyObjectType(name) {
    return new GraphQLObjectType({
        name: name + 'Placeholder',
        description: 'Placeholder object',
        fields: {
            message: {
                type: GraphQLString,
                description: 'Placeholder field',
                resolve: () => {
                    return 'This is a placeholder field.';
                }
            }
        }
    });
}

// Copyright IBM Corp. 2018. All Rights Reserved.
const translationLog$3 = debug('translation');
/**
 * Load the field object in the appropriate root object
 *
 * i.e. inside either rootQueryFields/rootMutationFields or inside
 * rootQueryFields/rootMutationFields for further processing
 */
function createAndLoadViewer(queryFields, operationType, data, fetch) {
    const results = {};
    /**
     * To ensure that viewers have unique names, we add a numerical postfix.
     *
     * This object keeps track of what the postfix should be.
     *
     * The key is the security scheme type and the value is
     * the current highest postfix used for viewers of that security scheme type.
     */
    const viewerNamePostfix = {};
    /**
     * Used to collect all fields in the given querFields object, no matter which
     * protocol. Used to populate anyAuthViewer.
     */
    const anyAuthFields = {};
    for (let protocolName in queryFields) {
        Object.assign(anyAuthFields, queryFields[protocolName]);
        /**
         * Check if the name has already been used (i.e. in the list)
         * if so, create a new name and add it to the list
         */
        const securityType = data.security[protocolName].def.type;
        let viewerType;
        /**
         * HTTP is not an authentication protocol
         * HTTP covers a number of different authentication type
         * change the typeName to match the exact authentication type (e.g. basic
         * authentication)
         */
        if (securityType === 'http') {
            let scheme = data.security[protocolName].def.scheme;
            switch (scheme) {
                case 'basic':
                    viewerType = 'basicAuth';
                    break;
                case 'bearer':
                    viewerType = 'bearerAuth';
                    break;
                default:
                    handleWarning({
                        mitigationType: MitigationTypes.UNSUPPORTED_HTTP_SECURITY_SCHEME,
                        message: `Currently unsupported HTTP authentication protocol ` +
                            `type 'http' and scheme '${scheme}'`,
                        data,
                        log: translationLog$3
                    });
                    continue;
            }
        }
        else {
            viewerType = securityType;
        }
        // Create name for the viewer
        let viewerName = operationType === GraphQLOperationType.Query
            ? sanitize(`viewer ${viewerType}`, CaseStyle.camelCase)
            : operationType === GraphQLOperationType.Mutation
                ? sanitize(`mutation viewer ${viewerType}`, CaseStyle.camelCase)
                : sanitize(`subscription viewer ${viewerType}`, CaseStyle.camelCase);
        // Ensure unique viewer name
        // If name already exists, append a number at the end of the name
        if (!(viewerType in viewerNamePostfix)) {
            viewerNamePostfix[viewerType] = 1;
        }
        else {
            viewerName += ++viewerNamePostfix[viewerType];
        }
        // Add the viewer object type to the specified root query object type
        results[viewerName] = getViewerOT(viewerName, protocolName, securityType, queryFields[protocolName], data);
    }
    // Create name for the AnyAuth viewer
    const anyAuthObjectName = operationType === GraphQLOperationType.Query
        ? 'viewerAnyAuth'
        : operationType === GraphQLOperationType.Mutation
            ? 'mutationViewerAnyAuth'
            : 'subscriptionViewerAnyAuth';
    // Add the AnyAuth object type to the specified root query object type
    results[anyAuthObjectName] = getViewerAnyAuthOT(anyAuthObjectName, anyAuthFields, data, fetch);
    return results;
}
/**
 * Get the viewer object, resolve function, and arguments
 */
function getViewerOT(name, protocolName, securityType, queryFields, data) {
    const scheme = data.security[protocolName];
    // Resolve function:
    const resolve = (source, args, context, info) => {
        const security = {};
        const saneProtocolName = sanitize(protocolName, CaseStyle.camelCase);
        security[storeSaneName(saneProtocolName, protocolName, data.saneMap)] = args;
        /**
         * Viewers are always root, so we can instantiate _openAPIToGraphQL here without
         * previously checking for its existence
         */
        return {
            _openAPIToGraphQL: {
                security
            }
        };
    };
    // Arguments:
    /**
     * Do not sort because they are already "sorted" in preprocessing.
     * Otherwise, for basic auth, "password" will appear before "username"
     */
    const args = {};
    if (typeof scheme === 'object') {
        for (let parameterName in scheme.parameters) {
            // The parameter name should be already sane as it is provided by OpenAPI-to-GraphQL
            const saneParameterName = sanitize(parameterName, CaseStyle.camelCase);
            args[saneParameterName] = { type: new GraphQLNonNull(GraphQLString) };
        }
    }
    let typeDescription = `A viewer for security scheme '${protocolName}'`;
    /**
     * HTTP authentication uses different schemes. It is not sufficient to name
     * only the security type
     */
    let description = securityType === 'http'
        ? `A viewer that wraps all operations authenticated via security scheme ` +
            `'${protocolName}', which is of type 'http' '${scheme.def.scheme}'`
        : `A viewer that wraps all operations authenticated via security scheme ` +
            `'${protocolName}', which is of type '${securityType}'`;
    if (data.oass.length !== 1) {
        typeDescription += ` in OAS '${scheme.oas.info.title}'`;
        description = `, in OAS '${scheme.oas.info.title}`;
    }
    return {
        type: new GraphQLObjectType({
            name: capitalize(name),
            description: typeDescription,
            fields: () => queryFields
        }),
        resolve,
        args,
        description
    };
}
/**
 * Create an object containing an AnyAuth viewer, its resolve function,
 * and its args.
 */
function getViewerAnyAuthOT(name, queryFields, data, fetch) {
    // Resolve function:
    const resolve = (source, args, context, info) => {
        return {
            _openAPIToGraphQL: {
                security: args
            }
        };
    };
    // Arguments:
    let args = {};
    for (let protocolName in data.security) {
        // Create input object types for the viewer arguments
        const def = createDataDef({ fromRef: protocolName }, data.security[protocolName].schema, true, data, data.security[protocolName].oas);
        const type = getGraphQLType({
            def,
            data,
            isInputObjectType: true,
            fetch
        });
        const saneProtocolName = sanitize(protocolName, CaseStyle.camelCase);
        args[storeSaneName(saneProtocolName, protocolName, data.saneMap)] = { type };
    }
    args = sortObject(args);
    return {
        type: new GraphQLObjectType({
            name: capitalize(name),
            description: 'Warning: Not every request will work with this viewer type',
            fields: () => queryFields
        }),
        resolve,
        args,
        description: `A viewer that wraps operations for all available ` +
            `authentication mechanisms`
    };
}

// Copyright IBM Corp. 2018. All Rights Reserved.
const translationLog$4 = debug('translation');
const DEFAULT_OPTIONS = {
    report: {
        warnings: [],
        numOps: 0,
        numOpsQuery: 0,
        numOpsMutation: 0,
        numOpsSubscription: 0,
        numQueriesCreated: 0,
        numMutationsCreated: 0,
        numSubscriptionsCreated: 0
    },
    // Setting default options
    strict: false,
    // Schema options
    operationIdFieldNames: false,
    fillEmptyResponses: false,
    addLimitArgument: false,
    idFormats: [],
    selectQueryOrMutationField: {},
    genericPayloadArgName: false,
    simpleNames: false,
    simpleEnumValues: false,
    singularNames: false,
    createSubscriptionsFromCallbacks: false,
    // Resolver options
    headers: {},
    qs: {},
    requestOptions: {},
    customResolvers: {},
    customSubscriptionResolvers: {},
    fileUploadOptions: {},
    // Authentication options
    viewer: true,
    sendOAuthTokenInQuery: false,
    // Validation options
    oasValidatorOptions: {},
    swagger2OpenAPIOptions: {},
    // Logging options
    provideErrorExtensions: true,
    equivalentToMessages: true,
    fetch: crossFetch
};
/**
 * Creates a GraphQL interface from the given OpenAPI Specification (2 or 3).
 */
async function createGraphQLSchema(spec, options) {
    // Setting default options
    const internalOptions = {
        ...DEFAULT_OPTIONS,
        ...options
    };
    if (Array.isArray(spec)) {
        // Convert all non-OAS 3 into OAS 3
        const oass = await Promise.all(spec.map((ele) => getValidOAS3(ele, internalOptions.oasValidatorOptions, internalOptions.swagger2OpenAPIOptions)));
        return translateOpenAPIToGraphQL(oass, internalOptions);
    }
    else {
        /**
         * Check if the spec is a valid OAS 3
         * If the spec is OAS 2.0, attempt to translate it into 3, then try to
         * translate the spec into a GraphQL schema
         */
        const oas = await getValidOAS3(spec, internalOptions.oasValidatorOptions, internalOptions.swagger2OpenAPIOptions);
        return translateOpenAPIToGraphQL([oas], internalOptions);
    }
}
/**
 * Creates a GraphQL interface from the given OpenAPI Specification 3
 */
function translateOpenAPIToGraphQL(oass, { strict, report, 
// Schema options
operationIdFieldNames, fillEmptyResponses, addLimitArgument, idFormats, selectQueryOrMutationField, genericPayloadArgName, simpleNames, simpleEnumValues, singularNames, createSubscriptionsFromCallbacks, 
// Resolver options
headers, qs, requestOptions, fileUploadOptions, connectOptions, baseUrl, customResolvers, customSubscriptionResolvers, 
// Authentication options
viewer, tokenJSONpath, sendOAuthTokenInQuery, 
// Validation options
oasValidatorOptions, swagger2OpenAPIOptions, 
// Logging options
provideErrorExtensions, equivalentToMessages, fetch }) {
    const options = {
        strict,
        report,
        // Schema options
        operationIdFieldNames,
        fillEmptyResponses,
        addLimitArgument,
        idFormats,
        selectQueryOrMutationField,
        genericPayloadArgName,
        simpleNames,
        simpleEnumValues,
        singularNames,
        createSubscriptionsFromCallbacks,
        // Resolver options
        headers,
        qs,
        requestOptions,
        fileUploadOptions,
        connectOptions,
        baseUrl,
        customResolvers,
        customSubscriptionResolvers,
        // Authentication options
        viewer,
        tokenJSONpath,
        sendOAuthTokenInQuery,
        // Validation options
        oasValidatorOptions,
        swagger2OpenAPIOptions,
        // Logging options
        provideErrorExtensions,
        equivalentToMessages,
        fetch
    };
    translationLog$4(`Options: ${JSON.stringify(options)}`);
    /**
     * Extract information from the OASs and put it inside a data structure that
     * is easier for OpenAPI-to-GraphQL to use
     */
    const data = preprocessOas(oass, options);
    preliminaryChecks(options, data);
    // Query, Mutation, and Subscription fields
    let queryFields = {};
    let mutationFields = {};
    let subscriptionFields = {};
    // Authenticated Query, Mutation, and Subscription fields
    let authQueryFields = {};
    let authMutationFields = {};
    let authSubscriptionFields = {};
    // Add Query and Mutation fields
    Object.entries(data.operations).forEach(([operationId, operation]) => {
        translationLog$4(`Process operation '${operation.operationString}'...`);
        // Check if the operation should be added as a Query or Mutation
        if (operation.operationType === GraphQLOperationType.Query) {
            addQueryFields({
                authQueryFields,
                queryFields,
                operationId,
                operation,
                options,
                data
            });
        }
        else if (operation.operationType === GraphQLOperationType.Mutation) {
            addMutationFields({
                authMutationFields,
                mutationFields,
                operationId,
                operation,
                options,
                data
            });
        }
    });
    // Add Subscription fields
    Object.entries(data.callbackOperations).forEach(([operationId, operation]) => {
        translationLog$4(`Process operation '${operationId}'...`);
        addSubscriptionFields({
            authSubscriptionFields,
            subscriptionFields,
            operationId,
            operation,
            options,
            data
        });
    });
    // Sorting fields
    queryFields = sortObject(queryFields);
    mutationFields = sortObject(mutationFields);
    subscriptionFields = sortObject(subscriptionFields);
    authQueryFields = sortObject(authQueryFields);
    Object.keys(authQueryFields).forEach((key) => {
        authQueryFields[key] = sortObject(authQueryFields[key]);
    });
    authMutationFields = sortObject(authMutationFields);
    Object.keys(authMutationFields).forEach((key) => {
        authMutationFields[key] = sortObject(authMutationFields[key]);
    });
    authSubscriptionFields = sortObject(authSubscriptionFields);
    Object.keys(authSubscriptionFields).forEach((key) => {
        authSubscriptionFields[key] = sortObject(authSubscriptionFields[key]);
    });
    // Count created Query, Mutation, and Subscription fields
    report.numQueriesCreated =
        Object.keys(queryFields).length +
            Object.keys(authQueryFields).reduce((sum, key) => {
                return sum + Object.keys(authQueryFields[key]).length;
            }, 0);
    report.numMutationsCreated =
        Object.keys(mutationFields).length +
            Object.keys(authMutationFields).reduce((sum, key) => {
                return sum + Object.keys(authMutationFields[key]).length;
            }, 0);
    report.numSubscriptionsCreated =
        Object.keys(subscriptionFields).length +
            Object.keys(authSubscriptionFields).reduce((sum, key) => {
                return sum + Object.keys(authSubscriptionFields[key]).length;
            }, 0);
    /**
     * Organize authenticated Query, Mutation, and Subscriptions fields into
     * viewer objects.
     */
    if (Object.keys(authQueryFields).length > 0) {
        Object.assign(queryFields, createAndLoadViewer(authQueryFields, GraphQLOperationType.Query, data, fetch));
    }
    if (Object.keys(authMutationFields).length > 0) {
        Object.assign(mutationFields, createAndLoadViewer(authMutationFields, GraphQLOperationType.Mutation, data, fetch));
    }
    if (Object.keys(authSubscriptionFields).length > 0) {
        Object.assign(subscriptionFields, createAndLoadViewer(authSubscriptionFields, GraphQLOperationType.Subscription, data, fetch));
    }
    // Build up the schema
    const schemaConfig = {
        query: Object.keys(queryFields).length > 0
            ? new GraphQLObjectType({
                name: 'Query',
                fields: queryFields
            })
            : getEmptyObjectType('Query'),
        mutation: Object.keys(mutationFields).length > 0
            ? new GraphQLObjectType({
                name: 'Mutation',
                fields: mutationFields
            })
            : null,
        subscription: Object.keys(subscriptionFields).length > 0
            ? new GraphQLObjectType({
                name: 'Subscription',
                fields: subscriptionFields
            })
            : null
    };
    /**
     * Fill in yet undefined object types to avoid GraphQLSchema from breaking.
     *
     * The reason: once creating the schema, the 'fields' thunks will resolve and
     * if a field references an undefined object type, GraphQL will throw.
     */
    Object.entries(data.operations).forEach(([opId, operation]) => {
        if (typeof operation.responseDefinition.graphQLType === 'undefined') {
            operation.responseDefinition.graphQLType =
                getEmptyObjectType(operation.responseDefinition.graphQLTypeName);
        }
    });
    const schema = new GraphQLSchema(schemaConfig);
    return { schema, report, data };
}
function addQueryFields({ authQueryFields, queryFields, operationId, operation, options, data }) {
    const { operationIdFieldNames, singularNames, baseUrl, requestOptions, fileUploadOptions, connectOptions, fetch } = options;
    const field = getFieldForOperation(operation, baseUrl, data, requestOptions, fileUploadOptions, connectOptions, fetch);
    const saneOperationId = sanitize(operationId, CaseStyle.camelCase);
    // Field name provided by x-graphql-field-name OAS extension
    const extensionFieldName = operation.operation[OAS_GRAPHQL_EXTENSIONS.FieldName];
    if (!isSanitized(extensionFieldName)) {
        throw new Error(`Cannot create query field with name "${extensionFieldName}".\nYou ` +
            `provided "${extensionFieldName}" in ` +
            `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it is not ` +
            `GraphQL-safe."`);
    }
    const generatedFieldName = operationIdFieldNames
        ? saneOperationId // Sanitized (generated) operationId
        : singularNames
            ? sanitize(
            // Generated singular name
            inferResourceNameFromPath(operation.path), CaseStyle.camelCase)
            : uncapitalize(
            // Generated type name (to be used as a field name)
            operation.responseDefinition.graphQLTypeName);
    /**
     * The name of the field
     *
     * Priority order:
     *  1. (extensionFieldName) if the field name is provided by
     * x-graphql-field-name OAS extension, use it.
     *
     *  2. (operationIdFieldNames) if the operationIdFieldNames option is set
     * to true, then use the sane operationId.
     *
     *  3. (singularNames) if the singularNames option is set to true, then
     * generate a singular name and use it.
     *
     *  4. (default) use the generated type name and use it.
     */
    let fieldName = extensionFieldName || generatedFieldName;
    // Generate viewer
    if (operation.inViewer) {
        for (let securityRequirement of operation.securityRequirements) {
            if (typeof authQueryFields[securityRequirement] !== 'object') {
                authQueryFields[securityRequirement] = {};
            }
            // Check for extensionFieldName because it can create conflicts
            if (extensionFieldName &&
                extensionFieldName in authQueryFields[securityRequirement]) {
                throw new Error(`Cannot create query field with name "${extensionFieldName}".\nYou ` +
                    ` provided "${extensionFieldName}" in ` +
                    `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it conflicts ` +
                    `with another field named "${extensionFieldName}".`);
            }
            /**
             * If using fieldName will cause a conflict, then try to use the
             * operationId instead.
             *
             * For example, the default behavior is to use the type name as a
             * field name and multiple operations can return the same type.
             */
            if (fieldName in authQueryFields[securityRequirement]) {
                fieldName = saneOperationId;
            }
            // Final fieldName verification
            if (fieldName in authQueryFields[securityRequirement]) {
                handleWarning({
                    mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                    message: `Multiple operations have the same name ` +
                        `'${fieldName}' and security requirement ` +
                        `'${securityRequirement}'. GraphQL field names must be ` +
                        `unique so only one can be added to the authentication ` +
                        `viewer. Operation '${operation.operationString}' will be ignored.`,
                    data,
                    log: translationLog$4
                });
                return;
            }
            authQueryFields[securityRequirement][fieldName] = field;
        }
    }
    else {
        // Check for extensionFieldName because it can create conflicts
        if (extensionFieldName && extensionFieldName in queryFields) {
            throw new Error(`Cannot create query field with name "${extensionFieldName}".\nYou ` +
                `provided "${extensionFieldName}" in ` +
                `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it conflicts ` +
                `with another field named "${extensionFieldName}".`);
        }
        /**
         * If using fieldName will cause a conflict, then try to use the
         * operationId instead.
         *
         * For example, the default behavior is to use the type name as a
         * field name and multiple operations can return the same type.
         */
        if (fieldName in queryFields) {
            fieldName = saneOperationId;
        }
        // Final fieldName verification
        if (fieldName in queryFields) {
            handleWarning({
                mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                message: `Multiple operations have the same name ` +
                    `'${fieldName}'. GraphQL field names must be ` +
                    `unique so only one can be added to the Query object. ` +
                    `Operation '${operation.operationString}' will be ignored.`,
                data,
                log: translationLog$4
            });
            return;
        }
        // Add field into Query
        queryFields[fieldName] = field;
    }
}
function addMutationFields({ authMutationFields, mutationFields, operationId, operation, options, data }) {
    const { singularNames, baseUrl, requestOptions, fileUploadOptions, connectOptions, fetch } = options;
    const field = getFieldForOperation(operation, baseUrl, data, requestOptions, fileUploadOptions, connectOptions, fetch);
    const saneOperationId = sanitize(operationId, CaseStyle.camelCase);
    // Field name provided by x-graphql-field-name OAS extension
    const extensionFieldName = operation.operation[OAS_GRAPHQL_EXTENSIONS.FieldName];
    if (!isSanitized(extensionFieldName)) {
        throw new Error(`Cannot create mutation field with name "${extensionFieldName}".\nYou ` +
            `provided "${extensionFieldName}" in ` +
            `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it is not ` +
            `GraphQL-safe."`);
    }
    const generatedFieldName = singularNames
        ? sanitize(
        // Generated singular name with HTTP method
        `${operation.method}${inferResourceNameFromPath(operation.path)}`, CaseStyle.camelCase)
        : saneOperationId; // (Generated) operationId (for mutations, operationId is guaranteed unique)
    /**
     * The name of the field
     *
     * Priority order:
     *  1. (extensionFieldName) if the field name is provided by
     * x-graphql-field-name OAS extension, use it.
     *
     *  2. (singularNames) if the singularNames option is set to true, then
     * generate a singular name with the HTTP method and use it.
     *
     *  3. (default) use the (generated) operationId.
     */
    const fieldName = extensionFieldName || generatedFieldName;
    // Generate viewer
    if (operation.inViewer) {
        for (let securityRequirement of operation.securityRequirements) {
            if (typeof authMutationFields[securityRequirement] !== 'object') {
                authMutationFields[securityRequirement] = {};
            }
            // Check for extensionFieldName because it can create conflicts
            if (extensionFieldName &&
                extensionFieldName in authMutationFields[securityRequirement]) {
                throw new Error(`Cannot create mutation field with name ` +
                    `"${extensionFieldName}".\nYou provided "${extensionFieldName}" ` +
                    `in ${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                    `conflicts with another field named "${extensionFieldName}".`);
            }
            // Final fieldName verification
            if (fieldName in authMutationFields[securityRequirement]) {
                handleWarning({
                    mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                    message: `Multiple operations have the same name ` +
                        `'${fieldName}' and security requirement ` +
                        `'${securityRequirement}'. GraphQL field names must be ` +
                        `unique so only one can be added to the authentication ` +
                        `viewer. Operation '${operation.operationString}' will be ignored.`,
                    data,
                    log: translationLog$4
                });
                return;
            }
            // Add field into viewer
            authMutationFields[securityRequirement][fieldName] = field;
        }
        // No viewer
    }
    else {
        // Check for extensionFieldName because it can create conflicts
        if (extensionFieldName && extensionFieldName in mutationFields) {
            throw new Error(`Cannot create mutation field with name ` +
                `"${extensionFieldName}".\nYou provided "${extensionFieldName}" ` +
                `in ${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                `conflicts with another field named "${extensionFieldName}".`);
        }
        // Final fieldName verification
        if (fieldName in mutationFields) {
            handleWarning({
                mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                message: `Multiple operations have the same name ` +
                    `'${fieldName}'. GraphQL field names must be ` +
                    `unique so only one can be added to the Mutation object. ` +
                    `Operation '${operation.operationString}' will be ignored.`,
                data,
                log: translationLog$4
            });
            return;
        }
        // Add field into Mutation
        mutationFields[fieldName] = field;
    }
}
function addSubscriptionFields({ authSubscriptionFields, subscriptionFields, operationId, operation, options, data }) {
    const { baseUrl, requestOptions, connectOptions, fetch, fileUploadOptions } = options;
    const field = getFieldForOperation(operation, baseUrl, data, requestOptions, fileUploadOptions, connectOptions, fetch);
    const saneOperationId = sanitize(operationId, CaseStyle.camelCase);
    const extensionFieldName = operation.operation[OAS_GRAPHQL_EXTENSIONS.FieldName];
    if (!isSanitized(extensionFieldName)) {
        throw new Error(`Cannot create subscription field with name ` +
            `"${extensionFieldName}".\nYou provided "${extensionFieldName}" in ` +
            `${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it is not ` +
            `GraphQL-safe."`);
    }
    const fieldName = extensionFieldName || saneOperationId;
    // Generate viewer
    if (operation.inViewer) {
        for (let securityRequirement of operation.securityRequirements) {
            if (typeof authSubscriptionFields[securityRequirement] !== 'object') {
                authSubscriptionFields[securityRequirement] = {};
            }
            if (extensionFieldName &&
                extensionFieldName in authSubscriptionFields[securityRequirement]) {
                throw new Error(`Cannot create subscription field with name ` +
                    `"${extensionFieldName}".\nYou provided "${extensionFieldName}" ` +
                    `in ${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                    `conflicts with another field named "${extensionFieldName}".`);
            }
            // Final fieldName verification
            if (fieldName in authSubscriptionFields[securityRequirement]) {
                handleWarning({
                    mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                    message: `Multiple operations have the same name ` +
                        `'${fieldName}' and security requirement ` +
                        `'${securityRequirement}'. GraphQL field names must be ` +
                        `unique so only one can be added to the authentication ` +
                        `viewer. Operation '${operation.operationString}' will be ignored.`,
                    data,
                    log: translationLog$4
                });
                return;
            }
            // Add field into viewer
            authSubscriptionFields[securityRequirement][fieldName] = field;
        }
        // No viewer
    }
    else {
        if (extensionFieldName && extensionFieldName in subscriptionFields) {
            throw new Error(`Cannot create subscription field with name ` +
                `"${extensionFieldName}".\nYou provided "${extensionFieldName}" ` +
                `in ${OAS_GRAPHQL_EXTENSIONS.FieldName}, but it ` +
                `conflicts with another field named "${extensionFieldName}".`);
        }
        // Final fieldName verification
        if (fieldName in subscriptionFields) {
            handleWarning({
                mitigationType: MitigationTypes.DUPLICATE_FIELD_NAME,
                message: `Multiple operations have the same name ` +
                    `'${fieldName}'. GraphQL field names must be ` +
                    `unique so only one can be added to the Mutation object. ` +
                    `Operation '${operation.operationString}' will be ignored.`,
                data,
                log: translationLog$4
            });
            return;
        }
        // Add field into Subscription
        subscriptionFields[fieldName] = field;
    }
}
/**
 * Creates the field object for the given operation.
 */
function getFieldForOperation(operation, baseUrl, data, requestOptions, fileUploadOptions, connectOptions, fetch) {
    // Create GraphQL Type for response:
    const type = getGraphQLType({
        def: operation.responseDefinition,
        data,
        operation,
        fetch
    });
    const payloadSchemaName = operation.payloadDefinition
        ? operation.payloadDefinition.graphQLInputObjectTypeName
        : null;
    const args = getArgs({
        /**
         * Even though these arguments seems redundent because of the operation
         * argument, the function cannot be refactored because it is also used to
         * create arguments for links. The operation argument is really used to pass
         * data to other functions.
         */
        requestPayloadDef: operation.payloadDefinition,
        parameters: operation.parameters,
        operation,
        data,
        fetch
    });
    // Get resolver and subscribe function for Subscription fields
    if (operation.operationType === GraphQLOperationType.Subscription) {
        const responseSchemaName = operation.responseDefinition
            ? operation.responseDefinition.graphQLTypeName
            : null;
        const resolve = getPublishResolver({
            operation,
            responseName: responseSchemaName,
            data,
            fetch
        });
        const subscribe = getSubscribe({
            operation,
            payloadName: payloadSchemaName,
            data,
            baseUrl,
            connectOptions
        });
        return {
            type,
            resolve,
            subscribe,
            args,
            description: operation.description
        };
        // Get resolver for Query and Mutation fields
    }
    else {
        const resolve = getResolver({
            operation,
            payloadName: payloadSchemaName,
            data,
            baseUrl,
            requestOptions,
            fileUploadOptions,
            fetch
        });
        return {
            type,
            resolve,
            args,
            description: operation.description
        };
    }
}
/**
 * Ensure that the customResolvers/customSubscriptionResolvers object is a
 * triply nested object using the name of the OAS, the path, and the method
 * as keys.
 */
function checkCustomResolversStructure(customResolvers, data) {
    if (typeof customResolvers === 'object') {
        // Check that all OASs that are referenced in the customResolvers are provided
        Object.keys(customResolvers)
            .filter((title) => {
            // If no OAS contains this title
            return !data.oass.some((oas) => {
                return title === oas.info.title;
            });
        })
            .forEach((title) => {
            handleWarning({
                mitigationType: MitigationTypes.CUSTOM_RESOLVER_UNKNOWN_OAS,
                message: `Custom resolvers reference OAS '${title}' but no such ` +
                    `OAS was provided`,
                data,
                log: translationLog$4
            });
        });
        // TODO: Only run the following test on OASs that exist. See previous check.
        Object.keys(customResolvers).forEach((title) => {
            // Get all operations from a particular OAS
            const operations = Object.values(data.operations).filter((operation) => {
                return title === operation.oas.info.title;
            });
            Object.keys(customResolvers[title]).forEach((path) => {
                Object.keys(customResolvers[title][path]).forEach((method) => {
                    if (!operations.some((operation) => {
                        return path === operation.path && method === operation.method;
                    })) {
                        handleWarning({
                            mitigationType: MitigationTypes.CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD,
                            message: `A custom resolver references an operation with ` +
                                `path '${path}' and method '${method}' but no such operation ` +
                                `exists in OAS '${title}'`,
                            data,
                            log: translationLog$4
                        });
                    }
                });
            });
        });
    }
}
/**
 * Ensures that the options are valid
 */
function preliminaryChecks(options, data) {
    // Check if OASs have unique titles
    const titles = data.oass.map((oas) => {
        return oas.info.title;
    });
    // Find duplicates among titles
    new Set(titles.filter((title, index) => {
        return titles.indexOf(title) !== index;
    })).forEach((title) => {
        handleWarning({
            mitigationType: MitigationTypes.MULTIPLE_OAS_SAME_TITLE,
            message: `Multiple OAS share the same title '${title}'`,
            data,
            log: translationLog$4
        });
    });
    // Check customResolvers
    checkCustomResolversStructure(options.customResolvers, data);
    // Check customSubscriptionResolvers
    checkCustomResolversStructure(options.customSubscriptionResolvers, data);
}

export { CaseStyle, GraphQLOperationType, createGraphQLSchema, sanitize, translateOpenAPIToGraphQL };
